/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 12);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"Component\", function() { return /* reexport */ Component; });\n__webpack_require__.d(__webpack_exports__, \"EMPTY_OBJ\", function() { return /* reexport */ EMPTY_OBJ; });\n__webpack_require__.d(__webpack_exports__, \"Fragment\", function() { return /* reexport */ Fragment; });\n__webpack_require__.d(__webpack_exports__, \"_CI\", function() { return /* reexport */ createClassComponentInstance; });\n__webpack_require__.d(__webpack_exports__, \"_HI\", function() { return /* reexport */ normalizeRoot; });\n__webpack_require__.d(__webpack_exports__, \"_M\", function() { return /* reexport */ mount; });\n__webpack_require__.d(__webpack_exports__, \"_MCCC\", function() { return /* reexport */ mountClassComponentCallbacks; });\n__webpack_require__.d(__webpack_exports__, \"_ME\", function() { return /* reexport */ mountElement; });\n__webpack_require__.d(__webpack_exports__, \"_MFCC\", function() { return /* reexport */ mountFunctionalComponentCallbacks; });\n__webpack_require__.d(__webpack_exports__, \"_MP\", function() { return /* reexport */ mountProps; });\n__webpack_require__.d(__webpack_exports__, \"_MR\", function() { return /* reexport */ mountRef; });\n__webpack_require__.d(__webpack_exports__, \"__render\", function() { return /* reexport */ __render; });\n__webpack_require__.d(__webpack_exports__, \"createComponentVNode\", function() { return /* reexport */ createComponentVNode; });\n__webpack_require__.d(__webpack_exports__, \"createFragment\", function() { return /* reexport */ createFragment; });\n__webpack_require__.d(__webpack_exports__, \"createPortal\", function() { return /* reexport */ createPortal; });\n__webpack_require__.d(__webpack_exports__, \"createRef\", function() { return /* reexport */ createRef; });\n__webpack_require__.d(__webpack_exports__, \"createRenderer\", function() { return /* reexport */ createRenderer; });\n__webpack_require__.d(__webpack_exports__, \"createTextVNode\", function() { return /* reexport */ createTextVNode; });\n__webpack_require__.d(__webpack_exports__, \"createVNode\", function() { return /* reexport */ createVNode; });\n__webpack_require__.d(__webpack_exports__, \"directClone\", function() { return /* reexport */ directClone; });\n__webpack_require__.d(__webpack_exports__, \"findDOMfromVNode\", function() { return /* reexport */ findDOMfromVNode; });\n__webpack_require__.d(__webpack_exports__, \"forwardRef\", function() { return /* reexport */ forwardRef; });\n__webpack_require__.d(__webpack_exports__, \"getFlagsForElementVnode\", function() { return /* reexport */ getFlagsForElementVnode; });\n__webpack_require__.d(__webpack_exports__, \"linkEvent\", function() { return /* reexport */ linkEvent; });\n__webpack_require__.d(__webpack_exports__, \"normalizeProps\", function() { return /* reexport */ normalizeProps; });\n__webpack_require__.d(__webpack_exports__, \"options\", function() { return /* reexport */ options; });\n__webpack_require__.d(__webpack_exports__, \"render\", function() { return /* reexport */ render; });\n__webpack_require__.d(__webpack_exports__, \"rerender\", function() { return /* reexport */ rerender; });\n__webpack_require__.d(__webpack_exports__, \"version\", function() { return /* reexport */ version; });\n\n// CONCATENATED MODULE: ./node_modules/inferno/dist/index.esm.js\nvar isArray = Array.isArray;\nfunction isStringOrNumber(o) {\n    var type = typeof o;\n    return type === 'string' || type === 'number';\n}\nfunction isNullOrUndef(o) {\n    return o === void 0 || o === null;\n}\nfunction isInvalid(o) {\n    return o === null || o === false || o === true || o === void 0;\n}\nfunction isFunction(o) {\n    return typeof o === 'function';\n}\nfunction isString(o) {\n    return typeof o === 'string';\n}\nfunction isNumber(o) {\n    return typeof o === 'number';\n}\nfunction isNull(o) {\n    return o === null;\n}\nfunction isUndefined(o) {\n    return o === void 0;\n}\nfunction combineFrom(first, second) {\n    var out = {};\n    if (first) {\n        for (var key in first) {\n            out[key] = first[key];\n        }\n    }\n    if (second) {\n        for (var key$1 in second) {\n            out[key$1] = second[key$1];\n        }\n    }\n    return out;\n}\n\n/**\n * Links given data to event as first parameter\n * @param {*} data data to be linked, it will be available in function as first parameter\n * @param {Function} event Function to be called when event occurs\n * @returns {{data: *, event: Function}}\n */\nfunction linkEvent(data, event) {\n    if (isFunction(event)) {\n        return { data: data, event: event };\n    }\n    return null; // Return null when event is invalid, to avoid creating unnecessary event handlers\n}\n// object.event should always be function, otherwise its badly created object.\nfunction isLinkEventObject(o) {\n    return !isNull(o) && typeof o === 'object';\n}\n\n// We need EMPTY_OBJ defined in one place.\n// Its used for comparison so we cant inline it into shared\nvar EMPTY_OBJ = {};\nvar Fragment = '$F';\nfunction normalizeEventName(name) {\n    return name.substr(2).toLowerCase();\n}\nfunction appendChild(parentDOM, dom) {\n    parentDOM.appendChild(dom);\n}\nfunction insertOrAppend(parentDOM, newNode, nextNode) {\n    if (isNull(nextNode)) {\n        appendChild(parentDOM, newNode);\n    }\n    else {\n        parentDOM.insertBefore(newNode, nextNode);\n    }\n}\nfunction documentCreateElement(tag, isSVG) {\n    if (isSVG) {\n        return document.createElementNS('http://www.w3.org/2000/svg', tag);\n    }\n    return document.createElement(tag);\n}\nfunction replaceChild(parentDOM, newDom, lastDom) {\n    parentDOM.replaceChild(newDom, lastDom);\n}\nfunction removeChild(parentDOM, childNode) {\n    parentDOM.removeChild(childNode);\n}\nfunction callAll(arrayFn) {\n    for (var i = 0; i < arrayFn.length; i++) {\n        arrayFn[i]();\n    }\n}\nfunction findChildVNode(vNode, startEdge, flags) {\n    var children = vNode.children;\n    if (flags & 4 /* ComponentClass */) {\n        return children.$LI;\n    }\n    if (flags & 8192 /* Fragment */) {\n        return vNode.childFlags === 2 /* HasVNodeChildren */ ? children : children[startEdge ? 0 : children.length - 1];\n    }\n    return children;\n}\nfunction findDOMfromVNode(vNode, startEdge) {\n    var flags;\n    while (vNode) {\n        flags = vNode.flags;\n        if (flags & 2033 /* DOMRef */) {\n            return vNode.dom;\n        }\n        vNode = findChildVNode(vNode, startEdge, flags);\n    }\n    return null;\n}\nfunction removeVNodeDOM(vNode, parentDOM) {\n    do {\n        var flags = vNode.flags;\n        if (flags & 2033 /* DOMRef */) {\n            removeChild(parentDOM, vNode.dom);\n            return;\n        }\n        var children = vNode.children;\n        if (flags & 4 /* ComponentClass */) {\n            vNode = children.$LI;\n        }\n        if (flags & 8 /* ComponentFunction */) {\n            vNode = children;\n        }\n        if (flags & 8192 /* Fragment */) {\n            if (vNode.childFlags === 2 /* HasVNodeChildren */) {\n                vNode = children;\n            }\n            else {\n                for (var i = 0, len = children.length; i < len; ++i) {\n                    removeVNodeDOM(children[i], parentDOM);\n                }\n                return;\n            }\n        }\n    } while (vNode);\n}\nfunction moveVNodeDOM(vNode, parentDOM, nextNode) {\n    do {\n        var flags = vNode.flags;\n        if (flags & 2033 /* DOMRef */) {\n            insertOrAppend(parentDOM, vNode.dom, nextNode);\n            return;\n        }\n        var children = vNode.children;\n        if (flags & 4 /* ComponentClass */) {\n            vNode = children.$LI;\n        }\n        if (flags & 8 /* ComponentFunction */) {\n            vNode = children;\n        }\n        if (flags & 8192 /* Fragment */) {\n            if (vNode.childFlags === 2 /* HasVNodeChildren */) {\n                vNode = children;\n            }\n            else {\n                for (var i = 0, len = children.length; i < len; ++i) {\n                    moveVNodeDOM(children[i], parentDOM, nextNode);\n                }\n                return;\n            }\n        }\n    } while (vNode);\n}\nfunction createDerivedState(instance, nextProps, state) {\n    if (instance.constructor.getDerivedStateFromProps) {\n        return combineFrom(state, instance.constructor.getDerivedStateFromProps(nextProps, state));\n    }\n    return state;\n}\nvar renderCheck = {\n    v: false\n};\nvar options = {\n    componentComparator: null,\n    createVNode: null,\n    renderComplete: null\n};\nfunction setTextContent(dom, children) {\n    dom.textContent = children;\n}\n// Calling this function assumes, nextValue is linkEvent\nfunction isLastValueSameLinkEvent(lastValue, nextValue) {\n    return (isLinkEventObject(lastValue) &&\n        lastValue.event === nextValue.event &&\n        lastValue.data === nextValue.data);\n}\nfunction mergeUnsetProperties(to, from) {\n    for (var propName in from) {\n        if (isUndefined(to[propName])) {\n            to[propName] = from[propName];\n        }\n    }\n    return to;\n}\nfunction safeCall1(method, arg1) {\n    return !!isFunction(method) && (method(arg1), true);\n}\n\nvar keyPrefix = '$';\nfunction V(childFlags, children, className, flags, key, props, ref, type) {\n    this.childFlags = childFlags;\n    this.children = children;\n    this.className = className;\n    this.dom = null;\n    this.flags = flags;\n    this.key = key === void 0 ? null : key;\n    this.props = props === void 0 ? null : props;\n    this.ref = ref === void 0 ? null : ref;\n    this.type = type;\n}\nfunction createVNode(flags, type, className, children, childFlags, props, key, ref) {\n    var childFlag = childFlags === void 0 ? 1 /* HasInvalidChildren */ : childFlags;\n    var vNode = new V(childFlag, children, className, flags, key, props, ref, type);\n    if (options.createVNode) {\n        options.createVNode(vNode);\n    }\n    if (childFlag === 0 /* UnknownChildren */) {\n        normalizeChildren(vNode, vNode.children);\n    }\n    return vNode;\n}\nfunction mergeDefaultHooks(flags, type, ref) {\n    if (flags & 4 /* ComponentClass */) {\n        return ref;\n    }\n    var defaultHooks = (flags & 32768 /* ForwardRef */ ? type.render : type).defaultHooks;\n    if (isNullOrUndef(defaultHooks)) {\n        return ref;\n    }\n    if (isNullOrUndef(ref)) {\n        return defaultHooks;\n    }\n    return mergeUnsetProperties(ref, defaultHooks);\n}\nfunction mergeDefaultProps(flags, type, props) {\n    // set default props\n    var defaultProps = (flags & 32768 /* ForwardRef */ ? type.render : type).defaultProps;\n    if (isNullOrUndef(defaultProps)) {\n        return props;\n    }\n    if (isNullOrUndef(props)) {\n        return combineFrom(defaultProps, null);\n    }\n    return mergeUnsetProperties(props, defaultProps);\n}\nfunction resolveComponentFlags(flags, type) {\n    if (flags & 12 /* ComponentKnown */) {\n        return flags;\n    }\n    if (type.prototype && type.prototype.render) {\n        return 4 /* ComponentClass */;\n    }\n    if (type.render) {\n        return 32776 /* ForwardRefComponent */;\n    }\n    return 8 /* ComponentFunction */;\n}\nfunction createComponentVNode(flags, type, props, key, ref) {\n    flags = resolveComponentFlags(flags, type);\n    var vNode = new V(1 /* HasInvalidChildren */, null, null, flags, key, mergeDefaultProps(flags, type, props), mergeDefaultHooks(flags, type, ref), type);\n    if (options.createVNode) {\n        options.createVNode(vNode);\n    }\n    return vNode;\n}\nfunction createTextVNode(text, key) {\n    return new V(1 /* HasInvalidChildren */, isNullOrUndef(text) || text === true || text === false ? '' : text, null, 16 /* Text */, key, null, null, null);\n}\nfunction createFragment(children, childFlags, key) {\n    var fragment = createVNode(8192 /* Fragment */, 8192 /* Fragment */, null, children, childFlags, null, key, null);\n    switch (fragment.childFlags) {\n        case 1 /* HasInvalidChildren */:\n            fragment.children = createVoidVNode();\n            fragment.childFlags = 2 /* HasVNodeChildren */;\n            break;\n        case 16 /* HasTextChildren */:\n            fragment.children = [createTextVNode(children)];\n            fragment.childFlags = 4 /* HasNonKeyedChildren */;\n            break;\n    }\n    return fragment;\n}\nfunction normalizeProps(vNode) {\n    var props = vNode.props;\n    if (props) {\n        var flags = vNode.flags;\n        if (flags & 481 /* Element */) {\n            if (props.children !== void 0 && isNullOrUndef(vNode.children)) {\n                normalizeChildren(vNode, props.children);\n            }\n            if (props.className !== void 0) {\n                vNode.className = props.className || null;\n                props.className = undefined;\n            }\n        }\n        if (props.key !== void 0) {\n            vNode.key = props.key;\n            props.key = undefined;\n        }\n        if (props.ref !== void 0) {\n            if (flags & 8 /* ComponentFunction */) {\n                vNode.ref = combineFrom(vNode.ref, props.ref);\n            }\n            else {\n                vNode.ref = props.ref;\n            }\n            props.ref = undefined;\n        }\n    }\n    return vNode;\n}\n/*\n * Fragment is different than normal vNode,\n * because when it needs to be cloned we need to clone its children too\n * But not normalize, because otherwise those possibly get KEY and re-mount\n */\nfunction cloneFragment(vNodeToClone) {\n    var clonedChildren;\n    var oldChildren = vNodeToClone.children;\n    var childFlags = vNodeToClone.childFlags;\n    if (childFlags === 2 /* HasVNodeChildren */) {\n        clonedChildren = directClone(oldChildren);\n    }\n    else if (childFlags & 12 /* MultipleChildren */) {\n        clonedChildren = [];\n        for (var i = 0, len = oldChildren.length; i < len; ++i) {\n            clonedChildren.push(directClone(oldChildren[i]));\n        }\n    }\n    return createFragment(clonedChildren, childFlags, vNodeToClone.key);\n}\nfunction directClone(vNodeToClone) {\n    var flags = vNodeToClone.flags & -16385 /* ClearInUse */;\n    var props = vNodeToClone.props;\n    if (flags & 14 /* Component */) {\n        if (!isNull(props)) {\n            var propsToClone = props;\n            props = {};\n            for (var key in propsToClone) {\n                props[key] = propsToClone[key];\n            }\n        }\n    }\n    if ((flags & 8192 /* Fragment */) === 0) {\n        return new V(vNodeToClone.childFlags, vNodeToClone.children, vNodeToClone.className, flags, vNodeToClone.key, props, vNodeToClone.ref, vNodeToClone.type);\n    }\n    return cloneFragment(vNodeToClone);\n}\nfunction createVoidVNode() {\n    return createTextVNode('', null);\n}\nfunction createPortal(children, container) {\n    var normalizedRoot = normalizeRoot(children);\n    return createVNode(1024 /* Portal */, 1024 /* Portal */, null, normalizedRoot, 0 /* UnknownChildren */, null, normalizedRoot.key, container);\n}\nfunction _normalizeVNodes(nodes, result, index, currentKey) {\n    for (var len = nodes.length; index < len; index++) {\n        var n = nodes[index];\n        if (!isInvalid(n)) {\n            var newKey = currentKey + keyPrefix + index;\n            if (isArray(n)) {\n                _normalizeVNodes(n, result, 0, newKey);\n            }\n            else {\n                if (isStringOrNumber(n)) {\n                    n = createTextVNode(n, newKey);\n                }\n                else {\n                    var oldKey = n.key;\n                    var isPrefixedKey = isString(oldKey) && oldKey[0] === keyPrefix;\n                    if (n.flags & 81920 /* InUseOrNormalized */ || isPrefixedKey) {\n                        n = directClone(n);\n                    }\n                    n.flags |= 65536 /* Normalized */;\n                    if (!isPrefixedKey) {\n                        if (isNull(oldKey)) {\n                            n.key = newKey;\n                        }\n                        else {\n                            n.key = currentKey + oldKey;\n                        }\n                    }\n                    else if (oldKey.substring(0, currentKey.length) !== currentKey) {\n                        n.key = currentKey + oldKey;\n                    }\n                }\n                result.push(n);\n            }\n        }\n    }\n}\nfunction getFlagsForElementVnode(type) {\n    switch (type) {\n        case 'svg':\n            return 32 /* SvgElement */;\n        case 'input':\n            return 64 /* InputElement */;\n        case 'select':\n            return 256 /* SelectElement */;\n        case 'textarea':\n            return 128 /* TextareaElement */;\n        case Fragment:\n            return 8192 /* Fragment */;\n        default:\n            return 1 /* HtmlElement */;\n    }\n}\nfunction normalizeChildren(vNode, children) {\n    var newChildren;\n    var newChildFlags = 1 /* HasInvalidChildren */;\n    // Don't change children to match strict equal (===) true in patching\n    if (isInvalid(children)) {\n        newChildren = children;\n    }\n    else if (isStringOrNumber(children)) {\n        newChildFlags = 16 /* HasTextChildren */;\n        newChildren = children;\n    }\n    else if (isArray(children)) {\n        var len = children.length;\n        for (var i = 0; i < len; ++i) {\n            var n = children[i];\n            if (isInvalid(n) || isArray(n)) {\n                newChildren = newChildren || children.slice(0, i);\n                _normalizeVNodes(children, newChildren, i, '');\n                break;\n            }\n            else if (isStringOrNumber(n)) {\n                newChildren = newChildren || children.slice(0, i);\n                newChildren.push(createTextVNode(n, keyPrefix + i));\n            }\n            else {\n                var key = n.key;\n                var needsCloning = (n.flags & 81920 /* InUseOrNormalized */) > 0;\n                var isNullKey = isNull(key);\n                var isPrefixed = isString(key) && key[0] === keyPrefix;\n                if (needsCloning || isNullKey || isPrefixed) {\n                    newChildren = newChildren || children.slice(0, i);\n                    if (needsCloning || isPrefixed) {\n                        n = directClone(n);\n                    }\n                    if (isNullKey || isPrefixed) {\n                        n.key = keyPrefix + i;\n                    }\n                    newChildren.push(n);\n                }\n                else if (newChildren) {\n                    newChildren.push(n);\n                }\n                n.flags |= 65536 /* Normalized */;\n            }\n        }\n        newChildren = newChildren || children;\n        if (newChildren.length === 0) {\n            newChildFlags = 1 /* HasInvalidChildren */;\n        }\n        else {\n            newChildFlags = 8 /* HasKeyedChildren */;\n        }\n    }\n    else {\n        newChildren = children;\n        newChildren.flags |= 65536 /* Normalized */;\n        if (children.flags & 81920 /* InUseOrNormalized */) {\n            newChildren = directClone(children);\n        }\n        newChildFlags = 2 /* HasVNodeChildren */;\n    }\n    vNode.children = newChildren;\n    vNode.childFlags = newChildFlags;\n    return vNode;\n}\nfunction normalizeRoot(input) {\n    if (isInvalid(input) || isStringOrNumber(input)) {\n        return createTextVNode(input, null);\n    }\n    if (isArray(input)) {\n        return createFragment(input, 0 /* UnknownChildren */, null);\n    }\n    return input.flags & 16384 /* InUse */ ? directClone(input) : input;\n}\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\nvar xmlNS = 'http://www.w3.org/XML/1998/namespace';\nvar namespaces = {\n    'xlink:actuate': xlinkNS,\n    'xlink:arcrole': xlinkNS,\n    'xlink:href': xlinkNS,\n    'xlink:role': xlinkNS,\n    'xlink:show': xlinkNS,\n    'xlink:title': xlinkNS,\n    'xlink:type': xlinkNS,\n    'xml:base': xmlNS,\n    'xml:lang': xmlNS,\n    'xml:space': xmlNS\n};\n\nfunction getDelegatedEventObject(v) {\n    return {\n        onClick: v,\n        onDblClick: v,\n        onFocusIn: v,\n        onFocusOut: v,\n        onKeyDown: v,\n        onKeyPress: v,\n        onKeyUp: v,\n        onMouseDown: v,\n        onMouseMove: v,\n        onMouseUp: v,\n        onTouchEnd: v,\n        onTouchMove: v,\n        onTouchStart: v\n    };\n}\nvar attachedEventCounts = getDelegatedEventObject(0);\nvar attachedEvents = getDelegatedEventObject(null);\nvar syntheticEvents = getDelegatedEventObject(true);\nfunction updateOrAddSyntheticEvent(name, dom) {\n    var eventsObject = dom.$EV;\n    if (!eventsObject) {\n        eventsObject = dom.$EV = getDelegatedEventObject(null);\n    }\n    if (!eventsObject[name]) {\n        if (++attachedEventCounts[name] === 1) {\n            attachedEvents[name] = attachEventToDocument(name);\n        }\n    }\n    return eventsObject;\n}\nfunction unmountSyntheticEvent(name, dom) {\n    var eventsObject = dom.$EV;\n    if (eventsObject && eventsObject[name]) {\n        if (--attachedEventCounts[name] === 0) {\n            document.removeEventListener(normalizeEventName(name), attachedEvents[name]);\n            attachedEvents[name] = null;\n        }\n        eventsObject[name] = null;\n    }\n}\nfunction handleSyntheticEvent(name, lastEvent, nextEvent, dom) {\n    if (isFunction(nextEvent)) {\n        updateOrAddSyntheticEvent(name, dom)[name] = nextEvent;\n    }\n    else if (isLinkEventObject(nextEvent)) {\n        if (isLastValueSameLinkEvent(lastEvent, nextEvent)) {\n            return;\n        }\n        updateOrAddSyntheticEvent(name, dom)[name] = nextEvent;\n    }\n    else {\n        unmountSyntheticEvent(name, dom);\n    }\n}\n// When browsers fully support event.composedPath we could loop it through instead of using parentNode property\nfunction getTargetNode(event) {\n    return isFunction(event.composedPath) ? event.composedPath()[0] : event.target;\n}\nfunction dispatchEvents(event, isClick, name, eventData) {\n    var dom = getTargetNode(event);\n    do {\n        // Html Nodes can be nested fe: span inside button in that scenario browser does not handle disabled attribute on parent,\n        // because the event listener is on document.body\n        // Don't process clicks on disabled elements\n        if (isClick && dom.disabled) {\n            return;\n        }\n        var eventsObject = dom.$EV;\n        if (eventsObject) {\n            var currentEvent = eventsObject[name];\n            if (currentEvent) {\n                // linkEvent object\n                eventData.dom = dom;\n                currentEvent.event ? currentEvent.event(currentEvent.data, event) : currentEvent(event);\n                if (event.cancelBubble) {\n                    return;\n                }\n            }\n        }\n        dom = dom.parentNode;\n    } while (!isNull(dom));\n}\nfunction stopPropagation() {\n    this.cancelBubble = true;\n    if (!this.immediatePropagationStopped) {\n        this.stopImmediatePropagation();\n    }\n}\nfunction isDefaultPrevented() {\n    return this.defaultPrevented;\n}\nfunction isPropagationStopped() {\n    return this.cancelBubble;\n}\nfunction extendEventProperties(event) {\n    // Event data needs to be object to save reference to currentTarget getter\n    var eventData = {\n        dom: document\n    };\n    event.isDefaultPrevented = isDefaultPrevented;\n    event.isPropagationStopped = isPropagationStopped;\n    event.stopPropagation = stopPropagation;\n    Object.defineProperty(event, 'currentTarget', {\n        configurable: true,\n        get: function get() {\n            return eventData.dom;\n        }\n    });\n    return eventData;\n}\nfunction rootClickEvent(name) {\n    return function (event) {\n        if (event.button !== 0) {\n            // Firefox incorrectly triggers click event for mid/right mouse buttons.\n            // This bug has been active for 17 years.\n            // https://bugzilla.mozilla.org/show_bug.cgi?id=184051\n            event.stopPropagation();\n            return;\n        }\n        dispatchEvents(event, true, name, extendEventProperties(event));\n    };\n}\nfunction rootEvent(name) {\n    return function (event) {\n        dispatchEvents(event, false, name, extendEventProperties(event));\n    };\n}\nfunction attachEventToDocument(name) {\n    var attachedEvent = name === 'onClick' || name === 'onDblClick' ? rootClickEvent(name) : rootEvent(name);\n    document.addEventListener(normalizeEventName(name), attachedEvent);\n    return attachedEvent;\n}\n\nfunction isSameInnerHTML(dom, innerHTML) {\n    var tempdom = document.createElement('i');\n    tempdom.innerHTML = innerHTML;\n    return tempdom.innerHTML === dom.innerHTML;\n}\n\nfunction triggerEventListener(props, methodName, e) {\n    if (props[methodName]) {\n        var listener = props[methodName];\n        if (listener.event) {\n            listener.event(listener.data, e);\n        }\n        else {\n            listener(e);\n        }\n    }\n    else {\n        var nativeListenerName = methodName.toLowerCase();\n        if (props[nativeListenerName]) {\n            props[nativeListenerName](e);\n        }\n    }\n}\nfunction createWrappedFunction(methodName, applyValue) {\n    var fnMethod = function (e) {\n        var vNode = this.$V;\n        // If vNode is gone by the time event fires, no-op\n        if (!vNode) {\n            return;\n        }\n        var props = vNode.props || EMPTY_OBJ;\n        var dom = vNode.dom;\n        if (isString(methodName)) {\n            triggerEventListener(props, methodName, e);\n        }\n        else {\n            for (var i = 0; i < methodName.length; ++i) {\n                triggerEventListener(props, methodName[i], e);\n            }\n        }\n        if (isFunction(applyValue)) {\n            var newVNode = this.$V;\n            var newProps = newVNode.props || EMPTY_OBJ;\n            applyValue(newProps, dom, false, newVNode);\n        }\n    };\n    Object.defineProperty(fnMethod, 'wrapped', {\n        configurable: false,\n        enumerable: false,\n        value: true,\n        writable: false\n    });\n    return fnMethod;\n}\n\nfunction attachEvent(dom, eventName, handler) {\n    var previousKey = \"$\" + eventName;\n    var previousArgs = dom[previousKey];\n    if (previousArgs) {\n        if (previousArgs[1].wrapped) {\n            return;\n        }\n        dom.removeEventListener(previousArgs[0], previousArgs[1]);\n        dom[previousKey] = null;\n    }\n    if (isFunction(handler)) {\n        dom.addEventListener(eventName, handler);\n        dom[previousKey] = [eventName, handler];\n    }\n}\n\nfunction isCheckedType(type) {\n    return type === 'checkbox' || type === 'radio';\n}\nvar onTextInputChange = createWrappedFunction('onInput', applyValueInput);\nvar wrappedOnChange = createWrappedFunction(['onClick', 'onChange'], applyValueInput);\n/* tslint:disable-next-line:no-empty */\nfunction emptywrapper(event) {\n    event.stopPropagation();\n}\nemptywrapper.wrapped = true;\nfunction inputEvents(dom, nextPropsOrEmpty) {\n    if (isCheckedType(nextPropsOrEmpty.type)) {\n        attachEvent(dom, 'change', wrappedOnChange);\n        attachEvent(dom, 'click', emptywrapper);\n    }\n    else {\n        attachEvent(dom, 'input', onTextInputChange);\n    }\n}\nfunction applyValueInput(nextPropsOrEmpty, dom) {\n    var type = nextPropsOrEmpty.type;\n    var value = nextPropsOrEmpty.value;\n    var checked = nextPropsOrEmpty.checked;\n    var multiple = nextPropsOrEmpty.multiple;\n    var defaultValue = nextPropsOrEmpty.defaultValue;\n    var hasValue = !isNullOrUndef(value);\n    if (type && type !== dom.type) {\n        dom.setAttribute('type', type);\n    }\n    if (!isNullOrUndef(multiple) && multiple !== dom.multiple) {\n        dom.multiple = multiple;\n    }\n    if (!isNullOrUndef(defaultValue) && !hasValue) {\n        dom.defaultValue = defaultValue + '';\n    }\n    if (isCheckedType(type)) {\n        if (hasValue) {\n            dom.value = value;\n        }\n        if (!isNullOrUndef(checked)) {\n            dom.checked = checked;\n        }\n    }\n    else {\n        if (hasValue && dom.value !== value) {\n            dom.defaultValue = value;\n            dom.value = value;\n        }\n        else if (!isNullOrUndef(checked)) {\n            dom.checked = checked;\n        }\n    }\n}\n\nfunction updateChildOptions(vNode, value) {\n    if (vNode.type === 'option') {\n        updateChildOption(vNode, value);\n    }\n    else {\n        var children = vNode.children;\n        var flags = vNode.flags;\n        if (flags & 4 /* ComponentClass */) {\n            updateChildOptions(children.$LI, value);\n        }\n        else if (flags & 8 /* ComponentFunction */) {\n            updateChildOptions(children, value);\n        }\n        else if (vNode.childFlags === 2 /* HasVNodeChildren */) {\n            updateChildOptions(children, value);\n        }\n        else if (vNode.childFlags & 12 /* MultipleChildren */) {\n            for (var i = 0, len = children.length; i < len; ++i) {\n                updateChildOptions(children[i], value);\n            }\n        }\n    }\n}\nfunction updateChildOption(vNode, value) {\n    var props = vNode.props || EMPTY_OBJ;\n    var dom = vNode.dom;\n    // we do this as multiple may have changed\n    dom.value = props.value;\n    if (props.value === value || (isArray(value) && value.indexOf(props.value) !== -1)) {\n        dom.selected = true;\n    }\n    else if (!isNullOrUndef(value) || !isNullOrUndef(props.selected)) {\n        dom.selected = props.selected || false;\n    }\n}\nvar onSelectChange = createWrappedFunction('onChange', applyValueSelect);\nfunction selectEvents(dom) {\n    attachEvent(dom, 'change', onSelectChange);\n}\nfunction applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode) {\n    var multiplePropInBoolean = Boolean(nextPropsOrEmpty.multiple);\n    if (!isNullOrUndef(nextPropsOrEmpty.multiple) && multiplePropInBoolean !== dom.multiple) {\n        dom.multiple = multiplePropInBoolean;\n    }\n    var index = nextPropsOrEmpty.selectedIndex;\n    if (index === -1) {\n        dom.selectedIndex = -1;\n    }\n    var childFlags = vNode.childFlags;\n    if (childFlags !== 1 /* HasInvalidChildren */) {\n        var value = nextPropsOrEmpty.value;\n        if (isNumber(index) && index > -1 && dom.options[index]) {\n            value = dom.options[index].value;\n        }\n        if (mounting && isNullOrUndef(value)) {\n            value = nextPropsOrEmpty.defaultValue;\n        }\n        updateChildOptions(vNode, value);\n    }\n}\n\nvar onTextareaInputChange = createWrappedFunction('onInput', applyValueTextArea);\nvar wrappedOnChange$1 = createWrappedFunction('onChange');\nfunction textAreaEvents(dom, nextPropsOrEmpty) {\n    attachEvent(dom, 'input', onTextareaInputChange);\n    if (nextPropsOrEmpty.onChange) {\n        attachEvent(dom, 'change', wrappedOnChange$1);\n    }\n}\nfunction applyValueTextArea(nextPropsOrEmpty, dom, mounting) {\n    var value = nextPropsOrEmpty.value;\n    var domValue = dom.value;\n    if (isNullOrUndef(value)) {\n        if (mounting) {\n            var defaultValue = nextPropsOrEmpty.defaultValue;\n            if (!isNullOrUndef(defaultValue) && defaultValue !== domValue) {\n                dom.defaultValue = defaultValue;\n                dom.value = defaultValue;\n            }\n        }\n    }\n    else if (domValue !== value) {\n        /* There is value so keep it controlled */\n        dom.defaultValue = value;\n        dom.value = value;\n    }\n}\n\n/**\n * There is currently no support for switching same input between controlled and nonControlled\n * If that ever becomes a real issue, then re design controlled elements\n * Currently user must choose either controlled or non-controlled and stick with that\n */\nfunction processElement(flags, vNode, dom, nextPropsOrEmpty, mounting, isControlled) {\n    if (flags & 64 /* InputElement */) {\n        applyValueInput(nextPropsOrEmpty, dom);\n    }\n    else if (flags & 256 /* SelectElement */) {\n        applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode);\n    }\n    else if (flags & 128 /* TextareaElement */) {\n        applyValueTextArea(nextPropsOrEmpty, dom, mounting);\n    }\n    if (isControlled) {\n        dom.$V = vNode;\n    }\n}\nfunction addFormElementEventHandlers(flags, dom, nextPropsOrEmpty) {\n    if (flags & 64 /* InputElement */) {\n        inputEvents(dom, nextPropsOrEmpty);\n    }\n    else if (flags & 256 /* SelectElement */) {\n        selectEvents(dom);\n    }\n    else if (flags & 128 /* TextareaElement */) {\n        textAreaEvents(dom, nextPropsOrEmpty);\n    }\n}\nfunction isControlledFormElement(nextPropsOrEmpty) {\n    return nextPropsOrEmpty.type && isCheckedType(nextPropsOrEmpty.type) ? !isNullOrUndef(nextPropsOrEmpty.checked) : !isNullOrUndef(nextPropsOrEmpty.value);\n}\n\nfunction createRef() {\n    return {\n        current: null\n    };\n}\nfunction forwardRef(render) {\n    return {\n        render: render\n    };\n}\nfunction unmountRef(ref) {\n    if (ref) {\n        if (!safeCall1(ref, null) && ref.current) {\n            ref.current = null;\n        }\n    }\n}\nfunction mountRef(ref, value, lifecycle) {\n    if (ref && (isFunction(ref) || ref.current !== void 0)) {\n        lifecycle.push(function () {\n            if (!safeCall1(ref, value) && ref.current !== void 0) {\n                ref.current = value;\n            }\n        });\n    }\n}\n\nfunction remove(vNode, parentDOM) {\n    unmount(vNode);\n    removeVNodeDOM(vNode, parentDOM);\n}\nfunction unmount(vNode) {\n    var flags = vNode.flags;\n    var children = vNode.children;\n    var ref;\n    if (flags & 481 /* Element */) {\n        ref = vNode.ref;\n        var props = vNode.props;\n        unmountRef(ref);\n        var childFlags = vNode.childFlags;\n        if (!isNull(props)) {\n            var keys = Object.keys(props);\n            for (var i = 0, len = keys.length; i < len; i++) {\n                var key = keys[i];\n                if (syntheticEvents[key]) {\n                    unmountSyntheticEvent(key, vNode.dom);\n                }\n            }\n        }\n        if (childFlags & 12 /* MultipleChildren */) {\n            unmountAllChildren(children);\n        }\n        else if (childFlags === 2 /* HasVNodeChildren */) {\n            unmount(children);\n        }\n    }\n    else if (children) {\n        if (flags & 4 /* ComponentClass */) {\n            if (isFunction(children.componentWillUnmount)) {\n                children.componentWillUnmount();\n            }\n            unmountRef(vNode.ref);\n            children.$UN = true;\n            unmount(children.$LI);\n        }\n        else if (flags & 8 /* ComponentFunction */) {\n            ref = vNode.ref;\n            if (!isNullOrUndef(ref) && isFunction(ref.onComponentWillUnmount)) {\n                ref.onComponentWillUnmount(findDOMfromVNode(vNode, true), vNode.props || EMPTY_OBJ);\n            }\n            unmount(children);\n        }\n        else if (flags & 1024 /* Portal */) {\n            remove(children, vNode.ref);\n        }\n        else if (flags & 8192 /* Fragment */) {\n            if (vNode.childFlags & 12 /* MultipleChildren */) {\n                unmountAllChildren(children);\n            }\n        }\n    }\n}\nfunction unmountAllChildren(children) {\n    for (var i = 0, len = children.length; i < len; ++i) {\n        unmount(children[i]);\n    }\n}\nfunction clearDOM(dom) {\n    // Optimization for clearing dom\n    dom.textContent = '';\n}\nfunction removeAllChildren(dom, vNode, children) {\n    unmountAllChildren(children);\n    if (vNode.flags & 8192 /* Fragment */) {\n        removeVNodeDOM(vNode, dom);\n    }\n    else {\n        clearDOM(dom);\n    }\n}\n\nfunction wrapLinkEvent(nextValue) {\n    // This variable makes sure there is no \"this\" context in callback\n    var ev = nextValue.event;\n    return function (e) {\n        ev(nextValue.data, e);\n    };\n}\nfunction patchEvent(name, lastValue, nextValue, dom) {\n    if (isLinkEventObject(nextValue)) {\n        if (isLastValueSameLinkEvent(lastValue, nextValue)) {\n            return;\n        }\n        nextValue = wrapLinkEvent(nextValue);\n    }\n    attachEvent(dom, normalizeEventName(name), nextValue);\n}\n// We are assuming here that we come from patchProp routine\n// -nextAttrValue cannot be null or undefined\nfunction patchStyle(lastAttrValue, nextAttrValue, dom) {\n    if (isNullOrUndef(nextAttrValue)) {\n        dom.removeAttribute('style');\n        return;\n    }\n    var domStyle = dom.style;\n    var style;\n    var value;\n    if (isString(nextAttrValue)) {\n        domStyle.cssText = nextAttrValue;\n        return;\n    }\n    if (!isNullOrUndef(lastAttrValue) && !isString(lastAttrValue)) {\n        for (style in nextAttrValue) {\n            // do not add a hasOwnProperty check here, it affects performance\n            value = nextAttrValue[style];\n            if (value !== lastAttrValue[style]) {\n                domStyle.setProperty(style, value);\n            }\n        }\n        for (style in lastAttrValue) {\n            if (isNullOrUndef(nextAttrValue[style])) {\n                domStyle.removeProperty(style);\n            }\n        }\n    }\n    else {\n        for (style in nextAttrValue) {\n            value = nextAttrValue[style];\n            domStyle.setProperty(style, value);\n        }\n    }\n}\nfunction patchDangerInnerHTML(lastValue, nextValue, lastVNode, dom) {\n    var lastHtml = (lastValue && lastValue.__html) || '';\n    var nextHtml = (nextValue && nextValue.__html) || '';\n    if (lastHtml !== nextHtml) {\n        if (!isNullOrUndef(nextHtml) && !isSameInnerHTML(dom, nextHtml)) {\n            if (!isNull(lastVNode)) {\n                if (lastVNode.childFlags & 12 /* MultipleChildren */) {\n                    unmountAllChildren(lastVNode.children);\n                }\n                else if (lastVNode.childFlags === 2 /* HasVNodeChildren */) {\n                    unmount(lastVNode.children);\n                }\n                lastVNode.children = null;\n                lastVNode.childFlags = 1 /* HasInvalidChildren */;\n            }\n            dom.innerHTML = nextHtml;\n        }\n    }\n}\nfunction patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode) {\n    switch (prop) {\n        case 'children':\n        case 'childrenType':\n        case 'className':\n        case 'defaultValue':\n        case 'key':\n        case 'multiple':\n        case 'ref':\n        case 'selectedIndex':\n            break;\n        case 'autoFocus':\n            dom.autofocus = !!nextValue;\n            break;\n        case 'allowfullscreen':\n        case 'autoplay':\n        case 'capture':\n        case 'checked':\n        case 'controls':\n        case 'default':\n        case 'disabled':\n        case 'hidden':\n        case 'indeterminate':\n        case 'loop':\n        case 'muted':\n        case 'novalidate':\n        case 'open':\n        case 'readOnly':\n        case 'required':\n        case 'reversed':\n        case 'scoped':\n        case 'seamless':\n        case 'selected':\n            dom[prop] = !!nextValue;\n            break;\n        case 'defaultChecked':\n        case 'value':\n        case 'volume':\n            if (hasControlledValue && prop === 'value') {\n                break;\n            }\n            var value = isNullOrUndef(nextValue) ? '' : nextValue;\n            if (dom[prop] !== value) {\n                dom[prop] = value;\n            }\n            break;\n        case 'style':\n            patchStyle(lastValue, nextValue, dom);\n            break;\n        case 'dangerouslySetInnerHTML':\n            patchDangerInnerHTML(lastValue, nextValue, lastVNode, dom);\n            break;\n        default:\n            if (syntheticEvents[prop]) {\n                handleSyntheticEvent(prop, lastValue, nextValue, dom);\n            }\n            else if (prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110) {\n                patchEvent(prop, lastValue, nextValue, dom);\n            }\n            else if (isNullOrUndef(nextValue)) {\n                dom.removeAttribute(prop);\n            }\n            else if (isSVG && namespaces[prop]) {\n                // We optimize for isSVG being false\n                // If we end up in this path we can read property again\n                dom.setAttributeNS(namespaces[prop], prop, nextValue);\n            }\n            else {\n                dom.setAttribute(prop, nextValue);\n            }\n            break;\n    }\n}\nfunction mountProps(vNode, flags, props, dom, isSVG) {\n    var hasControlledValue = false;\n    var isFormElement = (flags & 448 /* FormElement */) > 0;\n    if (isFormElement) {\n        hasControlledValue = isControlledFormElement(props);\n        if (hasControlledValue) {\n            addFormElementEventHandlers(flags, dom, props);\n        }\n    }\n    for (var prop in props) {\n        // do not add a hasOwnProperty check here, it affects performance\n        patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue, null);\n    }\n    if (isFormElement) {\n        processElement(flags, vNode, dom, props, true, hasControlledValue);\n    }\n}\n\nfunction renderNewInput(instance, props, context) {\n    var nextInput = normalizeRoot(instance.render(props, instance.state, context));\n    var childContext = context;\n    if (isFunction(instance.getChildContext)) {\n        childContext = combineFrom(context, instance.getChildContext());\n    }\n    instance.$CX = childContext;\n    return nextInput;\n}\nfunction createClassComponentInstance(vNode, Component, props, context, isSVG, lifecycle) {\n    var instance = new Component(props, context);\n    var usesNewAPI = (instance.$N = Boolean(Component.getDerivedStateFromProps || instance.getSnapshotBeforeUpdate));\n    instance.$SVG = isSVG;\n    instance.$L = lifecycle;\n    vNode.children = instance;\n    instance.$BS = false;\n    instance.context = context;\n    if (instance.props === EMPTY_OBJ) {\n        instance.props = props;\n    }\n    if (!usesNewAPI) {\n        if (isFunction(instance.componentWillMount)) {\n            instance.$BR = true;\n            instance.componentWillMount();\n            var pending = instance.$PS;\n            if (!isNull(pending)) {\n                var state = instance.state;\n                if (isNull(state)) {\n                    instance.state = pending;\n                }\n                else {\n                    for (var key in pending) {\n                        state[key] = pending[key];\n                    }\n                }\n                instance.$PS = null;\n            }\n            instance.$BR = false;\n        }\n    }\n    else {\n        instance.state = createDerivedState(instance, props, instance.state);\n    }\n    instance.$LI = renderNewInput(instance, props, context);\n    return instance;\n}\n\nfunction mount(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var flags = (vNode.flags |= 16384 /* InUse */);\n    if (flags & 481 /* Element */) {\n        mountElement(vNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n    else if (flags & 4 /* ComponentClass */) {\n        mountClassComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n    else if (flags & 8 /* ComponentFunction */) {\n        mountFunctionalComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle);\n        mountFunctionalComponentCallbacks(vNode, lifecycle);\n    }\n    else if (flags & 512 /* Void */ || flags & 16 /* Text */) {\n        mountText(vNode, parentDOM, nextNode);\n    }\n    else if (flags & 8192 /* Fragment */) {\n        mountFragment(vNode, context, parentDOM, isSVG, nextNode, lifecycle);\n    }\n    else if (flags & 1024 /* Portal */) {\n        mountPortal(vNode, context, parentDOM, nextNode, lifecycle);\n    }\n}\nfunction mountPortal(vNode, context, parentDOM, nextNode, lifecycle) {\n    mount(vNode.children, vNode.ref, context, false, null, lifecycle);\n    var placeHolderVNode = createVoidVNode();\n    mountText(placeHolderVNode, parentDOM, nextNode);\n    vNode.dom = placeHolderVNode.dom;\n}\nfunction mountFragment(vNode, context, parentDOM, isSVG, nextNode, lifecycle) {\n    var children = vNode.children;\n    var childFlags = vNode.childFlags;\n    // When fragment is optimized for multiple children, check if there is no children and change flag to invalid\n    // This is the only normalization always done, to keep optimization flags API same for fragments and regular elements\n    if (childFlags & 12 /* MultipleChildren */ && children.length === 0) {\n        childFlags = vNode.childFlags = 2 /* HasVNodeChildren */;\n        children = vNode.children = createVoidVNode();\n    }\n    if (childFlags === 2 /* HasVNodeChildren */) {\n        mount(children, parentDOM, nextNode, isSVG, nextNode, lifecycle);\n    }\n    else {\n        mountArrayChildren(children, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n}\nfunction mountText(vNode, parentDOM, nextNode) {\n    var dom = (vNode.dom = document.createTextNode(vNode.children));\n    if (!isNull(parentDOM)) {\n        insertOrAppend(parentDOM, dom, nextNode);\n    }\n}\nfunction mountElement(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var flags = vNode.flags;\n    var props = vNode.props;\n    var className = vNode.className;\n    var children = vNode.children;\n    var childFlags = vNode.childFlags;\n    var dom = (vNode.dom = documentCreateElement(vNode.type, (isSVG = isSVG || (flags & 32 /* SvgElement */) > 0)));\n    if (!isNullOrUndef(className) && className !== '') {\n        if (isSVG) {\n            dom.setAttribute('class', className);\n        }\n        else {\n            dom.className = className;\n        }\n    }\n    if (childFlags === 16 /* HasTextChildren */) {\n        setTextContent(dom, children);\n    }\n    else if (childFlags !== 1 /* HasInvalidChildren */) {\n        var childrenIsSVG = isSVG && vNode.type !== 'foreignObject';\n        if (childFlags === 2 /* HasVNodeChildren */) {\n            if (children.flags & 16384 /* InUse */) {\n                vNode.children = children = directClone(children);\n            }\n            mount(children, dom, context, childrenIsSVG, null, lifecycle);\n        }\n        else if (childFlags === 8 /* HasKeyedChildren */ || childFlags === 4 /* HasNonKeyedChildren */) {\n            mountArrayChildren(children, dom, context, childrenIsSVG, null, lifecycle);\n        }\n    }\n    if (!isNull(parentDOM)) {\n        insertOrAppend(parentDOM, dom, nextNode);\n    }\n    if (!isNull(props)) {\n        mountProps(vNode, flags, props, dom, isSVG);\n    }\n    mountRef(vNode.ref, dom, lifecycle);\n}\nfunction mountArrayChildren(children, dom, context, isSVG, nextNode, lifecycle) {\n    for (var i = 0; i < children.length; ++i) {\n        var child = children[i];\n        if (child.flags & 16384 /* InUse */) {\n            children[i] = child = directClone(child);\n        }\n        mount(child, dom, context, isSVG, nextNode, lifecycle);\n    }\n}\nfunction mountClassComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var instance = createClassComponentInstance(vNode, vNode.type, vNode.props || EMPTY_OBJ, context, isSVG, lifecycle);\n    mount(instance.$LI, parentDOM, instance.$CX, isSVG, nextNode, lifecycle);\n    mountClassComponentCallbacks(vNode.ref, instance, lifecycle);\n}\nfunction renderFunctionalComponent(vNode, context) {\n    return vNode.flags & 32768 /* ForwardRef */ ? vNode.type.render(vNode.props || EMPTY_OBJ, vNode.ref, context) : vNode.type(vNode.props || EMPTY_OBJ, context);\n}\nfunction mountFunctionalComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    mount((vNode.children = normalizeRoot(renderFunctionalComponent(vNode, context))), parentDOM, context, isSVG, nextNode, lifecycle);\n}\nfunction createClassMountCallback(instance) {\n    return function () {\n        instance.componentDidMount();\n    };\n}\nfunction mountClassComponentCallbacks(ref, instance, lifecycle) {\n    mountRef(ref, instance, lifecycle);\n    if (isFunction(instance.componentDidMount)) {\n        lifecycle.push(createClassMountCallback(instance));\n    }\n}\nfunction createOnMountCallback(ref, vNode) {\n    return function () {\n        ref.onComponentDidMount(findDOMfromVNode(vNode, true), vNode.props || EMPTY_OBJ);\n    };\n}\nfunction mountFunctionalComponentCallbacks(vNode, lifecycle) {\n    var ref = vNode.ref;\n    if (!isNullOrUndef(ref)) {\n        safeCall1(ref.onComponentWillMount, vNode.props || EMPTY_OBJ);\n        if (isFunction(ref.onComponentDidMount)) {\n            lifecycle.push(createOnMountCallback(ref, vNode));\n        }\n    }\n}\n\nfunction replaceWithNewNode(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle) {\n    unmount(lastVNode);\n    if ((nextVNode.flags & lastVNode.flags & 2033 /* DOMRef */) !== 0) {\n        mount(nextVNode, null, context, isSVG, null, lifecycle);\n        // Single DOM operation, when we have dom references available\n        replaceChild(parentDOM, nextVNode.dom, lastVNode.dom);\n    }\n    else {\n        mount(nextVNode, parentDOM, context, isSVG, findDOMfromVNode(lastVNode, true), lifecycle);\n        removeVNodeDOM(lastVNode, parentDOM);\n    }\n}\nfunction patch(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var nextFlags = (nextVNode.flags |= 16384 /* InUse */);\n    if (lastVNode.flags !== nextFlags || lastVNode.type !== nextVNode.type || lastVNode.key !== nextVNode.key || nextFlags & 2048 /* ReCreate */) {\n        if (lastVNode.flags & 16384 /* InUse */) {\n            replaceWithNewNode(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle);\n        }\n        else {\n            // Last vNode is not in use, it has crashed at application level. Just mount nextVNode and ignore last one\n            mount(nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);\n        }\n    }\n    else if (nextFlags & 481 /* Element */) {\n        patchElement(lastVNode, nextVNode, context, isSVG, nextFlags, lifecycle);\n    }\n    else if (nextFlags & 4 /* ComponentClass */) {\n        patchClassComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n    else if (nextFlags & 8 /* ComponentFunction */) {\n        patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n    else if (nextFlags & 16 /* Text */) {\n        patchText(lastVNode, nextVNode);\n    }\n    else if (nextFlags & 512 /* Void */) {\n        nextVNode.dom = lastVNode.dom;\n    }\n    else if (nextFlags & 8192 /* Fragment */) {\n        patchFragment(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle);\n    }\n    else {\n        patchPortal(lastVNode, nextVNode, context, lifecycle);\n    }\n}\nfunction patchSingleTextChild(lastChildren, nextChildren, parentDOM) {\n    if (lastChildren !== nextChildren) {\n        if (lastChildren !== '') {\n            parentDOM.firstChild.nodeValue = nextChildren;\n        }\n        else {\n            setTextContent(parentDOM, nextChildren);\n        }\n    }\n}\nfunction patchContentEditableChildren(dom, nextChildren) {\n    if (dom.textContent !== nextChildren) {\n        dom.textContent = nextChildren;\n    }\n}\nfunction patchFragment(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle) {\n    var lastChildren = lastVNode.children;\n    var nextChildren = nextVNode.children;\n    var lastChildFlags = lastVNode.childFlags;\n    var nextChildFlags = nextVNode.childFlags;\n    var nextNode = null;\n    // When fragment is optimized for multiple children, check if there is no children and change flag to invalid\n    // This is the only normalization always done, to keep optimization flags API same for fragments and regular elements\n    if (nextChildFlags & 12 /* MultipleChildren */ && nextChildren.length === 0) {\n        nextChildFlags = nextVNode.childFlags = 2 /* HasVNodeChildren */;\n        nextChildren = nextVNode.children = createVoidVNode();\n    }\n    var nextIsSingle = (nextChildFlags & 2 /* HasVNodeChildren */) !== 0;\n    if (lastChildFlags & 12 /* MultipleChildren */) {\n        var lastLen = lastChildren.length;\n        // We need to know Fragment's edge node when\n        if (\n        // It uses keyed algorithm\n        (lastChildFlags & 8 /* HasKeyedChildren */ && nextChildFlags & 8 /* HasKeyedChildren */) ||\n            // It transforms from many to single\n            nextIsSingle ||\n            // It will append more nodes\n            (!nextIsSingle && nextChildren.length > lastLen)) {\n            // When fragment has multiple children there is always at least one vNode\n            nextNode = findDOMfromVNode(lastChildren[lastLen - 1], false).nextSibling;\n        }\n    }\n    patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, lastVNode, lifecycle);\n}\nfunction patchPortal(lastVNode, nextVNode, context, lifecycle) {\n    var lastContainer = lastVNode.ref;\n    var nextContainer = nextVNode.ref;\n    var nextChildren = nextVNode.children;\n    patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, lastContainer, context, false, null, lastVNode, lifecycle);\n    nextVNode.dom = lastVNode.dom;\n    if (lastContainer !== nextContainer && !isInvalid(nextChildren)) {\n        var node = nextChildren.dom;\n        removeChild(lastContainer, node);\n        appendChild(nextContainer, node);\n    }\n}\nfunction patchElement(lastVNode, nextVNode, context, isSVG, nextFlags, lifecycle) {\n    var dom = (nextVNode.dom = lastVNode.dom);\n    var lastProps = lastVNode.props;\n    var nextProps = nextVNode.props;\n    var isFormElement = false;\n    var hasControlledValue = false;\n    var nextPropsOrEmpty;\n    isSVG = isSVG || (nextFlags & 32 /* SvgElement */) > 0;\n    // inlined patchProps  -- starts --\n    if (lastProps !== nextProps) {\n        var lastPropsOrEmpty = lastProps || EMPTY_OBJ;\n        nextPropsOrEmpty = nextProps || EMPTY_OBJ;\n        if (nextPropsOrEmpty !== EMPTY_OBJ) {\n            isFormElement = (nextFlags & 448 /* FormElement */) > 0;\n            if (isFormElement) {\n                hasControlledValue = isControlledFormElement(nextPropsOrEmpty);\n            }\n            for (var prop in nextPropsOrEmpty) {\n                var lastValue = lastPropsOrEmpty[prop];\n                var nextValue = nextPropsOrEmpty[prop];\n                if (lastValue !== nextValue) {\n                    patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode);\n                }\n            }\n        }\n        if (lastPropsOrEmpty !== EMPTY_OBJ) {\n            for (var prop$1 in lastPropsOrEmpty) {\n                if (isNullOrUndef(nextPropsOrEmpty[prop$1]) && !isNullOrUndef(lastPropsOrEmpty[prop$1])) {\n                    patchProp(prop$1, lastPropsOrEmpty[prop$1], null, dom, isSVG, hasControlledValue, lastVNode);\n                }\n            }\n        }\n    }\n    var nextChildren = nextVNode.children;\n    var nextClassName = nextVNode.className;\n    // inlined patchProps  -- ends --\n    if (lastVNode.className !== nextClassName) {\n        if (isNullOrUndef(nextClassName)) {\n            dom.removeAttribute('class');\n        }\n        else if (isSVG) {\n            dom.setAttribute('class', nextClassName);\n        }\n        else {\n            dom.className = nextClassName;\n        }\n    }\n    if (nextFlags & 4096 /* ContentEditable */) {\n        patchContentEditableChildren(dom, nextChildren);\n    }\n    else {\n        patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, dom, context, isSVG && nextVNode.type !== 'foreignObject', null, lastVNode, lifecycle);\n    }\n    if (isFormElement) {\n        processElement(nextFlags, nextVNode, dom, nextPropsOrEmpty, false, hasControlledValue);\n    }\n    var nextRef = nextVNode.ref;\n    var lastRef = lastVNode.ref;\n    if (lastRef !== nextRef) {\n        unmountRef(lastRef);\n        mountRef(nextRef, dom, lifecycle);\n    }\n}\nfunction replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context, isSVG, lifecycle) {\n    unmount(lastChildren);\n    mountArrayChildren(nextChildren, parentDOM, context, isSVG, findDOMfromVNode(lastChildren, true), lifecycle);\n    removeVNodeDOM(lastChildren, parentDOM);\n}\nfunction patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, parentVNode, lifecycle) {\n    switch (lastChildFlags) {\n        case 2 /* HasVNodeChildren */:\n            switch (nextChildFlags) {\n                case 2 /* HasVNodeChildren */:\n                    patch(lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n                case 1 /* HasInvalidChildren */:\n                    remove(lastChildren, parentDOM);\n                    break;\n                case 16 /* HasTextChildren */:\n                    unmount(lastChildren);\n                    setTextContent(parentDOM, nextChildren);\n                    break;\n                default:\n                    replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context, isSVG, lifecycle);\n                    break;\n            }\n            break;\n        case 1 /* HasInvalidChildren */:\n            switch (nextChildFlags) {\n                case 2 /* HasVNodeChildren */:\n                    mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n                case 1 /* HasInvalidChildren */:\n                    break;\n                case 16 /* HasTextChildren */:\n                    setTextContent(parentDOM, nextChildren);\n                    break;\n                default:\n                    mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n            }\n            break;\n        case 16 /* HasTextChildren */:\n            switch (nextChildFlags) {\n                case 16 /* HasTextChildren */:\n                    patchSingleTextChild(lastChildren, nextChildren, parentDOM);\n                    break;\n                case 2 /* HasVNodeChildren */:\n                    clearDOM(parentDOM);\n                    mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n                case 1 /* HasInvalidChildren */:\n                    clearDOM(parentDOM);\n                    break;\n                default:\n                    clearDOM(parentDOM);\n                    mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n            }\n            break;\n        default:\n            switch (nextChildFlags) {\n                case 16 /* HasTextChildren */:\n                    unmountAllChildren(lastChildren);\n                    setTextContent(parentDOM, nextChildren);\n                    break;\n                case 2 /* HasVNodeChildren */:\n                    removeAllChildren(parentDOM, parentVNode, lastChildren);\n                    mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n                case 1 /* HasInvalidChildren */:\n                    removeAllChildren(parentDOM, parentVNode, lastChildren);\n                    break;\n                default:\n                    var lastLength = lastChildren.length | 0;\n                    var nextLength = nextChildren.length | 0;\n                    // Fast path's for both algorithms\n                    if (lastLength === 0) {\n                        if (nextLength > 0) {\n                            mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                        }\n                    }\n                    else if (nextLength === 0) {\n                        removeAllChildren(parentDOM, parentVNode, lastChildren);\n                    }\n                    else if (nextChildFlags === 8 /* HasKeyedChildren */ && lastChildFlags === 8 /* HasKeyedChildren */) {\n                        patchKeyedChildren(lastChildren, nextChildren, parentDOM, context, isSVG, lastLength, nextLength, nextNode, parentVNode, lifecycle);\n                    }\n                    else {\n                        patchNonKeyedChildren(lastChildren, nextChildren, parentDOM, context, isSVG, lastLength, nextLength, nextNode, lifecycle);\n                    }\n                    break;\n            }\n            break;\n    }\n}\nfunction createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle) {\n    lifecycle.push(function () {\n        instance.componentDidUpdate(lastProps, lastState, snapshot);\n    });\n}\nfunction updateClassComponent(instance, nextState, nextProps, parentDOM, context, isSVG, force, nextNode, lifecycle) {\n    var lastState = instance.state;\n    var lastProps = instance.props;\n    var usesNewAPI = Boolean(instance.$N);\n    var hasSCU = isFunction(instance.shouldComponentUpdate);\n    if (usesNewAPI) {\n        nextState = createDerivedState(instance, nextProps, nextState !== lastState ? combineFrom(lastState, nextState) : nextState);\n    }\n    if (force || !hasSCU || (hasSCU && instance.shouldComponentUpdate(nextProps, nextState, context))) {\n        if (!usesNewAPI && isFunction(instance.componentWillUpdate)) {\n            instance.componentWillUpdate(nextProps, nextState, context);\n        }\n        instance.props = nextProps;\n        instance.state = nextState;\n        instance.context = context;\n        var snapshot = null;\n        var nextInput = renderNewInput(instance, nextProps, context);\n        if (usesNewAPI && isFunction(instance.getSnapshotBeforeUpdate)) {\n            snapshot = instance.getSnapshotBeforeUpdate(lastProps, lastState);\n        }\n        patch(instance.$LI, nextInput, parentDOM, instance.$CX, isSVG, nextNode, lifecycle);\n        // Dont update Last input, until patch has been succesfully executed\n        instance.$LI = nextInput;\n        if (isFunction(instance.componentDidUpdate)) {\n            createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle);\n        }\n    }\n    else {\n        instance.props = nextProps;\n        instance.state = nextState;\n        instance.context = context;\n    }\n}\nfunction patchClassComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var instance = (nextVNode.children = lastVNode.children);\n    // If Component has crashed, ignore it to stay functional\n    if (isNull(instance)) {\n        return;\n    }\n    instance.$L = lifecycle;\n    var nextProps = nextVNode.props || EMPTY_OBJ;\n    var nextRef = nextVNode.ref;\n    var lastRef = lastVNode.ref;\n    var nextState = instance.state;\n    if (!instance.$N) {\n        if (isFunction(instance.componentWillReceiveProps)) {\n            instance.$BR = true;\n            instance.componentWillReceiveProps(nextProps, context);\n            // If instance component was removed during its own update do nothing.\n            if (instance.$UN) {\n                return;\n            }\n            instance.$BR = false;\n        }\n        if (!isNull(instance.$PS)) {\n            nextState = combineFrom(nextState, instance.$PS);\n            instance.$PS = null;\n        }\n    }\n    updateClassComponent(instance, nextState, nextProps, parentDOM, context, isSVG, false, nextNode, lifecycle);\n    if (lastRef !== nextRef) {\n        unmountRef(lastRef);\n        mountRef(nextRef, instance, lifecycle);\n    }\n}\nfunction patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var shouldUpdate = true;\n    var nextProps = nextVNode.props || EMPTY_OBJ;\n    var nextRef = nextVNode.ref;\n    var lastProps = lastVNode.props;\n    var nextHooksDefined = !isNullOrUndef(nextRef);\n    var lastInput = lastVNode.children;\n    if (nextHooksDefined && isFunction(nextRef.onComponentShouldUpdate)) {\n        shouldUpdate = nextRef.onComponentShouldUpdate(lastProps, nextProps);\n    }\n    if (shouldUpdate !== false) {\n        if (nextHooksDefined && isFunction(nextRef.onComponentWillUpdate)) {\n            nextRef.onComponentWillUpdate(lastProps, nextProps);\n        }\n        var type = nextVNode.type;\n        var nextInput = normalizeRoot(nextVNode.flags & 32768 /* ForwardRef */ ? type.render(nextProps, nextRef, context) : type(nextProps, context));\n        patch(lastInput, nextInput, parentDOM, context, isSVG, nextNode, lifecycle);\n        nextVNode.children = nextInput;\n        if (nextHooksDefined && isFunction(nextRef.onComponentDidUpdate)) {\n            nextRef.onComponentDidUpdate(lastProps, nextProps);\n        }\n    }\n    else {\n        nextVNode.children = lastInput;\n    }\n}\nfunction patchText(lastVNode, nextVNode) {\n    var nextText = nextVNode.children;\n    var dom = (nextVNode.dom = lastVNode.dom);\n    if (nextText !== lastVNode.children) {\n        dom.nodeValue = nextText;\n    }\n}\nfunction patchNonKeyedChildren(lastChildren, nextChildren, dom, context, isSVG, lastChildrenLength, nextChildrenLength, nextNode, lifecycle) {\n    var commonLength = lastChildrenLength > nextChildrenLength ? nextChildrenLength : lastChildrenLength;\n    var i = 0;\n    var nextChild;\n    var lastChild;\n    for (; i < commonLength; ++i) {\n        nextChild = nextChildren[i];\n        lastChild = lastChildren[i];\n        if (nextChild.flags & 16384 /* InUse */) {\n            nextChild = nextChildren[i] = directClone(nextChild);\n        }\n        patch(lastChild, nextChild, dom, context, isSVG, nextNode, lifecycle);\n        lastChildren[i] = nextChild;\n    }\n    if (lastChildrenLength < nextChildrenLength) {\n        for (i = commonLength; i < nextChildrenLength; ++i) {\n            nextChild = nextChildren[i];\n            if (nextChild.flags & 16384 /* InUse */) {\n                nextChild = nextChildren[i] = directClone(nextChild);\n            }\n            mount(nextChild, dom, context, isSVG, nextNode, lifecycle);\n        }\n    }\n    else if (lastChildrenLength > nextChildrenLength) {\n        for (i = commonLength; i < lastChildrenLength; ++i) {\n            remove(lastChildren[i], dom);\n        }\n    }\n}\nfunction patchKeyedChildren(a, b, dom, context, isSVG, aLength, bLength, outerEdge, parentVNode, lifecycle) {\n    var aEnd = aLength - 1;\n    var bEnd = bLength - 1;\n    var j = 0;\n    var aNode = a[j];\n    var bNode = b[j];\n    var nextPos;\n    var nextNode;\n    // Step 1\n    // tslint:disable-next-line\n    outer: {\n        // Sync nodes with the same key at the beginning.\n        while (aNode.key === bNode.key) {\n            if (bNode.flags & 16384 /* InUse */) {\n                b[j] = bNode = directClone(bNode);\n            }\n            patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n            a[j] = bNode;\n            ++j;\n            if (j > aEnd || j > bEnd) {\n                break outer;\n            }\n            aNode = a[j];\n            bNode = b[j];\n        }\n        aNode = a[aEnd];\n        bNode = b[bEnd];\n        // Sync nodes with the same key at the end.\n        while (aNode.key === bNode.key) {\n            if (bNode.flags & 16384 /* InUse */) {\n                b[bEnd] = bNode = directClone(bNode);\n            }\n            patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n            a[aEnd] = bNode;\n            aEnd--;\n            bEnd--;\n            if (j > aEnd || j > bEnd) {\n                break outer;\n            }\n            aNode = a[aEnd];\n            bNode = b[bEnd];\n        }\n    }\n    if (j > aEnd) {\n        if (j <= bEnd) {\n            nextPos = bEnd + 1;\n            nextNode = nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge;\n            while (j <= bEnd) {\n                bNode = b[j];\n                if (bNode.flags & 16384 /* InUse */) {\n                    b[j] = bNode = directClone(bNode);\n                }\n                ++j;\n                mount(bNode, dom, context, isSVG, nextNode, lifecycle);\n            }\n        }\n    }\n    else if (j > bEnd) {\n        while (j <= aEnd) {\n            remove(a[j++], dom);\n        }\n    }\n    else {\n        patchKeyedChildrenComplex(a, b, context, aLength, bLength, aEnd, bEnd, j, dom, isSVG, outerEdge, parentVNode, lifecycle);\n    }\n}\nfunction patchKeyedChildrenComplex(a, b, context, aLength, bLength, aEnd, bEnd, j, dom, isSVG, outerEdge, parentVNode, lifecycle) {\n    var aNode;\n    var bNode;\n    var nextPos;\n    var i = 0;\n    var aStart = j;\n    var bStart = j;\n    var aLeft = aEnd - j + 1;\n    var bLeft = bEnd - j + 1;\n    var sources = new Int32Array(bLeft + 1);\n    // Keep track if its possible to remove whole DOM using textContent = '';\n    var canRemoveWholeContent = aLeft === aLength;\n    var moved = false;\n    var pos = 0;\n    var patched = 0;\n    // When sizes are small, just loop them through\n    if (bLength < 4 || (aLeft | bLeft) < 32) {\n        for (i = aStart; i <= aEnd; ++i) {\n            aNode = a[i];\n            if (patched < bLeft) {\n                for (j = bStart; j <= bEnd; j++) {\n                    bNode = b[j];\n                    if (aNode.key === bNode.key) {\n                        sources[j - bStart] = i + 1;\n                        if (canRemoveWholeContent) {\n                            canRemoveWholeContent = false;\n                            while (aStart < i) {\n                                remove(a[aStart++], dom);\n                            }\n                        }\n                        if (pos > j) {\n                            moved = true;\n                        }\n                        else {\n                            pos = j;\n                        }\n                        if (bNode.flags & 16384 /* InUse */) {\n                            b[j] = bNode = directClone(bNode);\n                        }\n                        patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n                        ++patched;\n                        break;\n                    }\n                }\n                if (!canRemoveWholeContent && j > bEnd) {\n                    remove(aNode, dom);\n                }\n            }\n            else if (!canRemoveWholeContent) {\n                remove(aNode, dom);\n            }\n        }\n    }\n    else {\n        var keyIndex = {};\n        // Map keys by their index\n        for (i = bStart; i <= bEnd; ++i) {\n            keyIndex[b[i].key] = i;\n        }\n        // Try to patch same keys\n        for (i = aStart; i <= aEnd; ++i) {\n            aNode = a[i];\n            if (patched < bLeft) {\n                j = keyIndex[aNode.key];\n                if (j !== void 0) {\n                    if (canRemoveWholeContent) {\n                        canRemoveWholeContent = false;\n                        while (i > aStart) {\n                            remove(a[aStart++], dom);\n                        }\n                    }\n                    sources[j - bStart] = i + 1;\n                    if (pos > j) {\n                        moved = true;\n                    }\n                    else {\n                        pos = j;\n                    }\n                    bNode = b[j];\n                    if (bNode.flags & 16384 /* InUse */) {\n                        b[j] = bNode = directClone(bNode);\n                    }\n                    patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n                    ++patched;\n                }\n                else if (!canRemoveWholeContent) {\n                    remove(aNode, dom);\n                }\n            }\n            else if (!canRemoveWholeContent) {\n                remove(aNode, dom);\n            }\n        }\n    }\n    // fast-path: if nothing patched remove all old and add all new\n    if (canRemoveWholeContent) {\n        removeAllChildren(dom, parentVNode, a);\n        mountArrayChildren(b, dom, context, isSVG, outerEdge, lifecycle);\n    }\n    else if (moved) {\n        var seq = lis_algorithm(sources);\n        j = seq.length - 1;\n        for (i = bLeft - 1; i >= 0; i--) {\n            if (sources[i] === 0) {\n                pos = i + bStart;\n                bNode = b[pos];\n                if (bNode.flags & 16384 /* InUse */) {\n                    b[pos] = bNode = directClone(bNode);\n                }\n                nextPos = pos + 1;\n                mount(bNode, dom, context, isSVG, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge, lifecycle);\n            }\n            else if (j < 0 || i !== seq[j]) {\n                pos = i + bStart;\n                bNode = b[pos];\n                nextPos = pos + 1;\n                moveVNodeDOM(bNode, dom, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge);\n            }\n            else {\n                j--;\n            }\n        }\n    }\n    else if (patched !== bLeft) {\n        // when patched count doesn't match b length we need to insert those new ones\n        // loop backwards so we can use insertBefore\n        for (i = bLeft - 1; i >= 0; i--) {\n            if (sources[i] === 0) {\n                pos = i + bStart;\n                bNode = b[pos];\n                if (bNode.flags & 16384 /* InUse */) {\n                    b[pos] = bNode = directClone(bNode);\n                }\n                nextPos = pos + 1;\n                mount(bNode, dom, context, isSVG, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge, lifecycle);\n            }\n        }\n    }\n}\nvar result;\nvar p;\nvar maxLen = 0;\n// https://en.wikipedia.org/wiki/Longest_increasing_subsequence\nfunction lis_algorithm(arr) {\n    var arrI = 0;\n    var i = 0;\n    var j = 0;\n    var k = 0;\n    var u = 0;\n    var v = 0;\n    var c = 0;\n    var len = arr.length;\n    if (len > maxLen) {\n        maxLen = len;\n        result = new Int32Array(len);\n        p = new Int32Array(len);\n    }\n    for (; i < len; ++i) {\n        arrI = arr[i];\n        if (arrI !== 0) {\n            j = result[k];\n            if (arr[j] < arrI) {\n                p[i] = j;\n                result[++k] = i;\n                continue;\n            }\n            u = 0;\n            v = k;\n            while (u < v) {\n                c = (u + v) >> 1;\n                if (arr[result[c]] < arrI) {\n                    u = c + 1;\n                }\n                else {\n                    v = c;\n                }\n            }\n            if (arrI < arr[result[u]]) {\n                if (u > 0) {\n                    p[i] = result[u - 1];\n                }\n                result[u] = i;\n            }\n        }\n    }\n    u = k + 1;\n    var seq = new Int32Array(u);\n    v = result[u - 1];\n    while (u-- > 0) {\n        seq[u] = v;\n        v = p[v];\n        result[u] = 0;\n    }\n    return seq;\n}\n\nvar hasDocumentAvailable = typeof document !== 'undefined';\nif (hasDocumentAvailable) {\n    /*\n     * Defining $EV and $V properties on Node.prototype\n     * fixes v8 \"wrong map\" de-optimization\n     */\n    if (window.Node) {\n        Node.prototype.$EV = null;\n        Node.prototype.$V = null;\n    }\n}\nfunction __render(input, parentDOM, callback, context) {\n    var lifecycle = [];\n    var rootInput = parentDOM.$V;\n    renderCheck.v = true;\n    if (isNullOrUndef(rootInput)) {\n        if (!isNullOrUndef(input)) {\n            if (input.flags & 16384 /* InUse */) {\n                input = directClone(input);\n            }\n            mount(input, parentDOM, context, false, null, lifecycle);\n            parentDOM.$V = input;\n            rootInput = input;\n        }\n    }\n    else {\n        if (isNullOrUndef(input)) {\n            remove(rootInput, parentDOM);\n            parentDOM.$V = null;\n        }\n        else {\n            if (input.flags & 16384 /* InUse */) {\n                input = directClone(input);\n            }\n            patch(rootInput, input, parentDOM, context, false, null, lifecycle);\n            rootInput = parentDOM.$V = input;\n        }\n    }\n    callAll(lifecycle);\n    renderCheck.v = false;\n    if (isFunction(callback)) {\n        callback();\n    }\n    if (isFunction(options.renderComplete)) {\n        options.renderComplete(rootInput, parentDOM);\n    }\n}\nfunction render(input, parentDOM, callback, context) {\n    if ( callback === void 0 ) callback = null;\n    if ( context === void 0 ) context = EMPTY_OBJ;\n\n    __render(input, parentDOM, callback, context);\n}\nfunction createRenderer(parentDOM) {\n    return function renderer(lastInput, nextInput, callback, context) {\n        if (!parentDOM) {\n            parentDOM = lastInput;\n        }\n        render(nextInput, parentDOM, callback, context);\n    };\n}\n\nvar QUEUE = [];\nvar nextTick = typeof Promise !== 'undefined'\n    ? Promise.resolve().then.bind(Promise.resolve())\n    : function (a) {\n        window.setTimeout(a, 0);\n    };\nvar microTaskPending = false;\nfunction queueStateChanges(component, newState, callback, force) {\n    var pending = component.$PS;\n    if (isFunction(newState)) {\n        newState = newState(pending ? combineFrom(component.state, pending) : component.state, component.props, component.context);\n    }\n    if (isNullOrUndef(pending)) {\n        component.$PS = newState;\n    }\n    else {\n        for (var stateKey in newState) {\n            pending[stateKey] = newState[stateKey];\n        }\n    }\n    if (!component.$BR) {\n        if (!renderCheck.v) {\n            if (QUEUE.length === 0) {\n                applyState(component, force);\n                if (isFunction(callback)) {\n                    callback.call(component);\n                }\n                return;\n            }\n        }\n        if (QUEUE.indexOf(component) === -1) {\n            QUEUE.push(component);\n        }\n        if (!microTaskPending) {\n            microTaskPending = true;\n            nextTick(rerender);\n        }\n        if (isFunction(callback)) {\n            var QU = component.$QU;\n            if (!QU) {\n                QU = component.$QU = [];\n            }\n            QU.push(callback);\n        }\n    }\n    else if (isFunction(callback)) {\n        component.$L.push(callback.bind(component));\n    }\n}\nfunction callSetStateCallbacks(component) {\n    var queue = component.$QU;\n    for (var i = 0; i < queue.length; ++i) {\n        queue[i].call(component);\n    }\n    component.$QU = null;\n}\nfunction rerender() {\n    var component;\n    microTaskPending = false;\n    while ((component = QUEUE.shift())) {\n        if (!component.$UN) {\n            applyState(component, false);\n            if (component.$QU) {\n                callSetStateCallbacks(component);\n            }\n        }\n    }\n}\nfunction applyState(component, force) {\n    if (force || !component.$BR) {\n        var pendingState = component.$PS;\n        component.$PS = null;\n        var lifecycle = [];\n        renderCheck.v = true;\n        updateClassComponent(component, combineFrom(component.state, pendingState), component.props, findDOMfromVNode(component.$LI, true).parentNode, component.context, component.$SVG, force, null, lifecycle);\n        callAll(lifecycle);\n        renderCheck.v = false;\n    }\n    else {\n        component.state = component.$PS;\n        component.$PS = null;\n    }\n}\nvar Component = function Component(props, context) {\n    // Public\n    this.state = null;\n    // Internal properties\n    this.$BR = false; // BLOCK RENDER\n    this.$BS = true; // BLOCK STATE\n    this.$PS = null; // PENDING STATE (PARTIAL or FULL)\n    this.$LI = null; // LAST INPUT\n    this.$UN = false; // UNMOUNTED\n    this.$CX = null; // CHILDCONTEXT\n    this.$QU = null; // QUEUE\n    this.$N = false; // Uses new lifecycle API Flag\n    this.$L = null; // Current lifecycle of this component\n    this.$SVG = false; // Flag to keep track if component is inside SVG tree\n    this.props = props || EMPTY_OBJ;\n    this.context = context || EMPTY_OBJ; // context should not be mutable\n};\nComponent.prototype.forceUpdate = function forceUpdate (callback) {\n    if (this.$UN) {\n        return;\n    }\n    // Do not allow double render during force update\n    queueStateChanges(this, {}, callback, true);\n};\nComponent.prototype.setState = function setState (newState, callback) {\n    if (this.$UN) {\n        return;\n    }\n    if (!this.$BS) {\n        queueStateChanges(this, newState, callback, false);\n    }\n};\nComponent.prototype.render = function render (_nextProps, _nextState, _nextContext) {\n    return null;\n};\n\nvar version = \"7.4.2\";\n\n\n\n// CONCATENATED MODULE: ./node_modules/inferno/index.esm.js\n\n\nif (false) {}\n\n\n//# sourceURL=webpack:///./node_modules/inferno/index.esm.js_+_1_modules?");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar bind = __webpack_require__(2);\n\n/*global toString:true*/\n\n// utils is a library of generic helper functions non-specific to axios\n\nvar toString = Object.prototype.toString;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\nfunction isArray(val) {\n  return toString.call(val) === '[object Array]';\n}\n\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\n    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nfunction isArrayBuffer(val) {\n  return toString.call(val) === '[object ArrayBuffer]';\n}\n\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nfunction isFormData(val) {\n  return (typeof FormData !== 'undefined') && (val instanceof FormData);\n}\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  var result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\nfunction isObject(val) {\n  return val !== null && typeof val === 'object';\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\nfunction isDate(val) {\n  return toString.call(val) === '[object Date]';\n}\n\n/**\n * Determine if a value is a File\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nfunction isFile(val) {\n  return toString.call(val) === '[object File]';\n}\n\n/**\n * Determine if a value is a Blob\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nfunction isBlob(val) {\n  return toString.call(val) === '[object Blob]';\n}\n\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nfunction isURLSearchParams(val) {\n  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;\n}\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\nfunction trim(str) {\n  return str.replace(/^\\s*/, '').replace(/\\s*$/, '');\n}\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n */\nfunction isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||\n                                           navigator.product === 'NativeScript' ||\n                                           navigator.product === 'NS')) {\n    return false;\n  }\n  return (\n    typeof window !== 'undefined' &&\n    typeof document !== 'undefined'\n  );\n}\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (typeof result[key] === 'object' && typeof val === 'object') {\n      result[key] = merge(result[key], val);\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Function equal to merge with the difference being that no reference\n * to original objects is kept.\n *\n * @see merge\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction deepMerge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (typeof result[key] === 'object' && typeof val === 'object') {\n      result[key] = deepMerge(result[key], val);\n    } else if (typeof val === 'object') {\n      result[key] = deepMerge({}, val);\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  deepMerge: deepMerge,\n  extend: extend,\n  trim: trim\n};\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/utils.js?");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    return fn.apply(thisArg, args);\n  };\n};\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/bind.js?");

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(1);\n\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%40/gi, '@').\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      } else {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    var hashmarkIndex = url.indexOf('#');\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/buildURL.js?");

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/cancel/isCancel.js?");

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nvar utils = __webpack_require__(1);\nvar normalizeHeaderName = __webpack_require__(26);\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = __webpack_require__(6);\n  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {\n    // For node use HTTP adapter\n    adapter = __webpack_require__(6);\n  }\n  return adapter;\n}\n\nvar defaults = {\n  adapter: getDefaultAdapter(),\n\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Accept');\n    normalizeHeaderName(headers, 'Content-Type');\n    if (utils.isFormData(data) ||\n      utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n    if (utils.isObject(data)) {\n      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');\n      return JSON.stringify(data);\n    }\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    /*eslint no-param-reassign:0*/\n    if (typeof data === 'string') {\n      try {\n        data = JSON.parse(data);\n      } catch (e) { /* Ignore */ }\n    }\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  }\n};\n\ndefaults.headers = {\n  common: {\n    'Accept': 'application/json, text/plain, */*'\n  }\n};\n\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n\nmodule.exports = defaults;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(25)))\n\n//# sourceURL=webpack:///./node_modules/axios/lib/defaults.js?");

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(1);\nvar settle = __webpack_require__(27);\nvar buildURL = __webpack_require__(3);\nvar buildFullPath = __webpack_require__(29);\nvar parseHeaders = __webpack_require__(32);\nvar isURLSameOrigin = __webpack_require__(33);\nvar createError = __webpack_require__(7);\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n\n    if (utils.isFormData(requestData)) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest();\n\n    // HTTP basic authentication\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password || '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    var fullPath = buildFullPath(config.baseURL, config.url);\n    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    // Listen for ready state\n    request.onreadystatechange = function handleLoad() {\n      if (!request || request.readyState !== 4) {\n        return;\n      }\n\n      // The request errored out and we didn't get a response, this will be\n      // handled by onerror instead\n      // With one exception: request that using file: protocol, most browsers\n      // will return status as 0 even though it's a successful request\n      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n        return;\n      }\n\n      // Prepare the response\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;\n      var response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n\n      settle(resolve, reject, response);\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(createError('Request aborted', config, 'ECONNABORTED', request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(createError('Network Error', config, null, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';\n      if (config.timeoutErrorMessage) {\n        timeoutErrorMessage = config.timeoutErrorMessage;\n      }\n      reject(createError(timeoutErrorMessage, config, 'ECONNABORTED',\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (utils.isStandardBrowserEnv()) {\n      var cookies = __webpack_require__(34);\n\n      // Add xsrf header\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?\n        cookies.read(config.xsrfCookieName) :\n        undefined;\n\n      if (xsrfValue) {\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\n      }\n    }\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils.isUndefined(config.withCredentials)) {\n      request.withCredentials = !!config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (config.responseType) {\n      try {\n        request.responseType = config.responseType;\n      } catch (e) {\n        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.\n        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.\n        if (config.responseType !== 'json') {\n          throw e;\n        }\n      }\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken) {\n      // Handle cancellation\n      config.cancelToken.promise.then(function onCanceled(cancel) {\n        if (!request) {\n          return;\n        }\n\n        request.abort();\n        reject(cancel);\n        // Clean up request\n        request = null;\n      });\n    }\n\n    if (requestData === undefined) {\n      requestData = null;\n    }\n\n    // Send the request\n    request.send(requestData);\n  });\n};\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/adapters/xhr.js?");

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar enhanceError = __webpack_require__(28);\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\nmodule.exports = function createError(message, config, code, request, response) {\n  var error = new Error(message);\n  return enhanceError(error, config, code, request, response);\n};\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/createError.js?");

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(1);\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n * @returns {Object} New object resulting from merging config2 to config1\n */\nmodule.exports = function mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  var config = {};\n\n  var valueFromConfig2Keys = ['url', 'method', 'params', 'data'];\n  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy'];\n  var defaultToConfig2Keys = [\n    'baseURL', 'url', 'transformRequest', 'transformResponse', 'paramsSerializer',\n    'timeout', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',\n    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress',\n    'maxContentLength', 'validateStatus', 'maxRedirects', 'httpAgent',\n    'httpsAgent', 'cancelToken', 'socketPath'\n  ];\n\n  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {\n    if (typeof config2[prop] !== 'undefined') {\n      config[prop] = config2[prop];\n    }\n  });\n\n  utils.forEach(mergeDeepPropertiesKeys, function mergeDeepProperties(prop) {\n    if (utils.isObject(config2[prop])) {\n      config[prop] = utils.deepMerge(config1[prop], config2[prop]);\n    } else if (typeof config2[prop] !== 'undefined') {\n      config[prop] = config2[prop];\n    } else if (utils.isObject(config1[prop])) {\n      config[prop] = utils.deepMerge(config1[prop]);\n    } else if (typeof config1[prop] !== 'undefined') {\n      config[prop] = config1[prop];\n    }\n  });\n\n  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {\n    if (typeof config2[prop] !== 'undefined') {\n      config[prop] = config2[prop];\n    } else if (typeof config1[prop] !== 'undefined') {\n      config[prop] = config1[prop];\n    }\n  });\n\n  var axiosKeys = valueFromConfig2Keys\n    .concat(mergeDeepPropertiesKeys)\n    .concat(defaultToConfig2Keys);\n\n  var otherKeys = Object\n    .keys(config2)\n    .filter(function filterAxiosKeys(key) {\n      return axiosKeys.indexOf(key) === -1;\n    });\n\n  utils.forEach(otherKeys, function otherKeysDefaultToConfig2(prop) {\n    if (typeof config2[prop] !== 'undefined') {\n      config[prop] = config2[prop];\n    } else if (typeof config1[prop] !== 'undefined') {\n      config[prop] = config1[prop];\n    }\n  });\n\n  return config;\n};\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/mergeConfig.js?");

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * A `Cancel` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */\nfunction Cancel(message) {\n  this.message = message;\n}\n\nCancel.prototype.toString = function toString() {\n  return 'Cancel' + (this.message ? ': ' + this.message : '');\n};\n\nCancel.prototype.__CANCEL__ = true;\n\nmodule.exports = Cancel;\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/cancel/Cancel.js?");

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

eval("var pathToRegExp = __webpack_require__(16)\r\n\r\n/**\r\n * Expose `pathToRegexp` as ES6 module\r\n */\r\nmodule.exports = pathToRegExp;\r\nmodule.exports.parse = pathToRegExp.parse\r\nmodule.exports.compile = pathToRegExp.compile\r\nmodule.exports.tokensToFunction = pathToRegExp.tokensToFunction\r\nmodule.exports.tokensToRegExp = pathToRegExp.tokensToRegExp\r\nmodule.exports['default'] = module.exports;\r\n\n\n//# sourceURL=webpack:///./node_modules/path-to-regexp-es6/index.js?");

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar INFERNO_STATICS = {\n    childContextTypes: true,\n    contextTypes: true,\n    defaultProps: true,\n    displayName: true,\n    getDefaultProps: true,\n    propTypes: true,\n    type: true\n};\n\nvar KNOWN_STATICS = {\n    name: true,\n    length: true,\n    prototype: true,\n    caller: true,\n    arguments: true,\n    arity: true\n};\n\nvar isGetOwnPropertySymbolsAvailable = typeof Object.getOwnPropertySymbols === 'function';\n\nfunction hoistNonReactStatics(targetComponent, sourceComponent, customStatics) {\n    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components\n        var keys = Object.getOwnPropertyNames(sourceComponent);\n\n        /* istanbul ignore else */\n        if (isGetOwnPropertySymbolsAvailable) {\n            keys = keys.concat(Object.getOwnPropertySymbols(sourceComponent));\n        }\n\n        for (var i = 0; i < keys.length; ++i) {\n            if (!INFERNO_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]] && (!customStatics || !customStatics[keys[i]])) {\n                try {\n                    targetComponent[keys[i]] = sourceComponent[keys[i]];\n                } catch (error) {\n\n                }\n            }\n        }\n    }\n\n    return targetComponent;\n};\n\nmodule.exports = hoistNonReactStatics;\nmodule.exports.default = module.exports;\n\n\n//# sourceURL=webpack:///./node_modules/hoist-non-inferno-statics/index.js?");

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _inferno = __webpack_require__(0);\n\nvar _jsmlI = __webpack_require__(13);\n\nvar _jsmlI2 = _interopRequireDefault(_jsmlI);\n\nvar _infernoComponent = __webpack_require__(15);\n\nvar _infernoComponent2 = _interopRequireDefault(_infernoComponent);\n\nvar _infernoRouter = __webpack_require__(37);\n\nvar _data = __webpack_require__(18);\n\nvar _data2 = _interopRequireDefault(_data);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Main = function (_Component) {\n\t_inherits(Main, _Component);\n\n\tfunction Main(props) {\n\t\t_classCallCheck(this, Main);\n\n\t\tvar _this = _possibleConstructorReturn(this, (Main.__proto__ || Object.getPrototypeOf(Main)).call(this, props));\n\n\t\t_this.state = {};return _this;\n\t}\n\n\t_createClass(Main, [{\n\t\tkey: 'componentWillMount',\n\t\tvalue: function componentWillMount() {}\n\t}, {\n\t\tkey: 'render',\n\t\tvalue: function render() {\n\t\t\treturn (0, _jsmlI2.default)('div', {}, (0, _jsmlI2.default)(_infernoRouter.HashRouter, { hashType: 'slash',\n\t\t\t\tbaseName: '/' }, (0, _jsmlI2.default)(_infernoRouter.Route, { path: [\"/bible/:book/:chapter/:verse/:reference\", \"/bible/:book/:chapter/:verse\", \"/bible/:book/:chapter\", \"/bible/:book\", \"/bible\"],\n\n\t\t\t\texact: true,\n\t\t\t\trender: function render(props) {\n\t\t\t\t\tvar match = false;\n\t\t\t\t\tprops.match.path.map(function (path) {\n\t\t\t\t\t\tmatch = match || (0, _infernoRouter.matchPath)(props.location.pathname, { path: path, exact: true, strict: false });\n\t\t\t\t\t});\n\n\t\t\t\t\treturn (0, _jsmlI2.default)(MainPage, _extends({ viewing: 'bible',\n\t\t\t\t\t\tbible_params: {\n\t\t\t\t\t\t\tbook: match.params.book || 'matthew',\n\t\t\t\t\t\t\tchapter: int(match.params.chapter || 1),\n\t\t\t\t\t\t\tverse: int(match.params.verse || 1) },\n\t\t\t\t\t\ttranslation: 'douay',\n\t\t\t\t\t\treference: match.params.reference\n\t\t\t\t\t}, props));\n\t\t\t\t} }), (0, _jsmlI2.default)(_infernoRouter.Route, { path: [\"/lectionary/:year/:month/:day/:reference\", \"/lectionary/:year/:month/:day\", \"/lectionary/today\"],\n\n\t\t\t\texact: true,\n\t\t\t\trender: function render(props) {\n\t\t\t\t\tvar match = false;\n\t\t\t\t\tprops.match.path.map(function (path) {\n\t\t\t\t\t\tmatch = match || (0, _infernoRouter.matchPath)(props.location.pathname, { path: path, exact: true, strict: false });\n\t\t\t\t\t});\n\t\t\t\t\tvar year, month, day;\n\n\t\t\t\t\tif (props.location.pathname == '/lectionary/todaay') {\n\t\t\t\t\t\tvar date = new Date();\n\t\t\t\t\t\tday = date.getDate();\n\t\t\t\t\t\tmonth = date.getMonth() + 1;\n\t\t\t\t\t\tyear = date.getYear() - 100;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tyear = int(match.params.year);\n\t\t\t\t\t\tmonth = int(match.params.month);\n\t\t\t\t\t\tday = int(match.params.day);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn (0, _jsmlI2.default)(MainPage, _extends({ viewing: 'lectionary',\n\t\t\t\t\t\tlectionary_params: {\n\t\t\t\t\t\t\tyear: year, month: month, day: day },\n\t\t\t\t\t\ttranslation: 'douay',\n\t\t\t\t\t\treference: match.params.reference\n\t\t\t\t\t}, props));\n\t\t\t\t} }), !window.location.hash && (0, _jsmlI2.default)(_infernoRouter.Redirect, { from: \"/\", to: \"/bible\" })));\n\t\t}\n\t}]);\n\n\treturn Main;\n}(_infernoComponent2.default);\n\nvar MainPage = function (_Component2) {\n\t_inherits(MainPage, _Component2);\n\n\tfunction MainPage(props) {\n\t\t_classCallCheck(this, MainPage);\n\n\t\tvar _this2 = _possibleConstructorReturn(this, (MainPage.__proto__ || Object.getPrototypeOf(MainPage)).call(this, props));\n\n\t\t_this2.state = { toc: { bible: {} } };return _this2;\n\t}\n\n\t_createClass(MainPage, [{\n\t\tkey: 'componentWillMount',\n\t\tvalue: function componentWillMount() {\n\t\t\tvar _this3 = this;\n\n\t\t\tthis.bible_data = new _data2.default();\n\t\t\tthis.bible_data.get_toc(function (toc) {\n\t\t\t\treturn _this3.setState({ toc: toc });\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: 'open_reference',\n\t\tvalue: function open_reference(ref, verse) {\n\t\t\tif (!verse) verse = ref.verse;\n\t\t\tthis.props.history.push('/bible/' + ref.book + \"/\" + ref.chapter + \"/\" + ref.verse + \"/\" + ref.source_code + \":\" + verse);\n\t\t}\n\t}, {\n\t\tkey: 'close_reference',\n\t\tvalue: function close_reference() {\n\t\t\tthis.props.history.push('/bible/' + ref.book + \"/\" + ref.chapter + \"/\" + ref.verse);\n\t\t}\n\t}, {\n\t\tkey: 'get_references',\n\t\tvalue: function get_references(book, chapter, verse) {\n\t\t\treturn _get_references(book, chapter, verse, this.state.books);\n\t\t}\n\t}, {\n\t\tkey: 'go_to_next_reference',\n\t\tvalue: function go_to_next_reference(ref, refs, open_reference) {\n\t\t\tvar found = false;\n\n\t\t\tfor (var i in refs) {\n\t\t\t\tvar r = refs[i];\n\t\t\t\tconsole.log({ r: r, ref: ref }, r == ref);\n\t\t\t\tif (found) return (open_reference || this.open_reference)(r);\n\t\t\t\tif (r == ref) found = true;\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'go_to_previous_reference',\n\t\tvalue: function go_to_previous_reference(ref, refs, open_reference) {\n\t\t\tvar last = false;\n\n\t\t\tfor (var i in refs) {\n\t\t\t\tvar r = refs[i];\n\t\t\t\tif (last && r == ref) return (open_reference || this.open_reference)(last);\n\t\t\t\tlast = r;\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'render',\n\t\tvalue: function render(_ref) {\n\t\t\tvar _this4 = this;\n\n\t\t\tvar bible_params = _ref.bible_params,\n\t\t\t    viewing = _ref.viewing,\n\t\t\t    lectionary_params = _ref.lectionary_params,\n\t\t\t    reference = _ref.reference,\n\t\t\t    translation = _ref.translation;\n\n\t\t\tvar actions = {\n\t\t\t\tnavigate: function navigate(x) {\n\t\t\t\t\treturn _this4.props.history.push(x);\n\t\t\t\t},\n\t\t\t\topen_reference: this.open_reference.bind(this),\n\t\t\t\tclose_reference: this.close_reference.bind(this),\n\t\t\t\tgo_to_next_reference: this.go_to_next_reference.bind(this),\n\t\t\t\tgo_to_previous_reference: this.go_to_previous_reference.bind(this) };\n\n\t\t\treturn (0, _jsmlI2.default)('div', {}, (0, _jsmlI2.default)('div', { id: 'main-reader' }, (0, _jsmlI2.default)(Navigation, { nav_open: this.state.nav_open,\n\t\t\t\ttoc: this.state.toc,\n\t\t\t\tactions: {\n\t\t\t\t\topen_chapter: function open_chapter(book, verse) {\n\t\t\t\t\t\t_this4.setState({ nav_open: false });\n\t\t\t\t\t\t_this4.props.history.push(\"/bible/\" + book + \"/\" + verse);\n\t\t\t\t\t},\n\t\t\t\t\topen_nav: function open_nav() {\n\t\t\t\t\t\t_this4.setState({ nav_open: !_this4.state.nav_open,\n\t\t\t\t\t\t\tlect_nav_open: false });\n\t\t\t\t\t} } }), (0, _jsmlI2.default)(LectionaryNavigation, {\n\t\t\t\tnav_open: this.state.lect_nav_open,\n\t\t\t\tdate: this.props.lectionary_params ? new Date(\"20\" + this.props.lectionary_params.year + \"-\" + this.props.lectionary_params.month + \"-\" + this.props.lectionary_params.day) : new Date(),\n\t\t\t\tactions: {\n\t\t\t\t\topen_day: function open_day(year, month, day) {\n\t\t\t\t\t\t_this4.setState({ lect_nav_open: false });\n\t\t\t\t\t\t_this4.props.history.push(\"/lectionary/\" + year + \"/\" + month + \"/\" + day);\n\t\t\t\t\t},\n\t\t\t\t\topen_today: function open_today() {\n\t\t\t\t\t\t_this4.setState({ lect_nav_open: false });\n\t\t\t\t\t\t_this4.props.history.push(\"/lectionary/today\");\n\t\t\t\t\t},\n\t\t\t\t\topen_nav: function open_nav() {\n\t\t\t\t\t\t_this4.setState({ lect_nav_open: !_this4.state.lect_nav_open,\n\t\t\t\t\t\t\tnav_open: false });\n\t\t\t\t\t} } }), viewing == 'lectionary' && (0, _jsmlI2.default)(Lectionary, {\n\t\t\t\tday: lectionary_params.day,\n\t\t\t\tyear: lectionary_params.year,\n\t\t\t\tmonth: lectionary_params.month,\n\t\t\t\tbible_data: this.bible_data,\n\t\t\t\treference: reference,\n\t\t\t\ttranslation: translation,\n\t\t\t\tactions: actions }), viewing == 'bible' && (0, _jsmlI2.default)(BibleChapter, {\n\t\t\t\tbook: bible_params.book,\n\t\t\t\tchapter: bible_params.chapter,\n\t\t\t\tverse: bible_params.verse,\n\t\t\t\tbible_data: this.bible_data,\n\t\t\t\treference: reference,\n\t\t\t\ttranslation: translation,\n\t\t\t\tactions: actions })));\n\t\t}\n\t}]);\n\n\treturn MainPage;\n}(_infernoComponent2.default);\n\nvar BibleChapter = function (_Component3) {\n\t_inherits(BibleChapter, _Component3);\n\n\tfunction BibleChapter(props) {\n\t\t_classCallCheck(this, BibleChapter);\n\n\t\tvar _this5 = _possibleConstructorReturn(this, (BibleChapter.__proto__ || Object.getPrototypeOf(BibleChapter)).call(this, props));\n\n\t\t_this5.state = { books: {},\n\t\t\ttoc: { bible: {} } };return _this5;\n\t}\n\n\t_createClass(BibleChapter, [{\n\t\tkey: 'componentWillMount',\n\t\tvalue: function componentWillMount() {\n\t\t\tthis.bible_data = this.props.bible_data;\n\t\t\tthis.load_data(this.props);\n\t\t}\n\t}, {\n\t\tkey: 'componentWillReceiveProps',\n\t\tvalue: function componentWillReceiveProps(props) {\n\t\t\tif (props.book != this.props.book || props.chapter != this.props.chapter || props.verse != this.props.verse || props.reference != this.props.reference) this.load_data(props);\n\t\t}\n\t}, {\n\t\tkey: 'load_data',\n\t\tvalue: function load_data(props) {\n\t\t\tvar _this6 = this;\n\n\t\t\tthis.bible_data.get_chapter({ book: props.book,\n\t\t\t\tchapter: props.chapter,\n\t\t\t\tverse: props.verse,\n\t\t\t\treference: props.reference }, function (book) {\n\t\t\t\t_this6.setState({ books: Object.assign(_this6.state.books, _defineProperty({}, props.book, _defineProperty({}, props.chapter, book))) });\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: 'render',\n\t\tvalue: function render(_ref2) {\n\t\t\tvar book = _ref2.book,\n\t\t\t    chapter = _ref2.chapter,\n\t\t\t    verse = _ref2.verse,\n\t\t\t    reference = _ref2.reference,\n\t\t\t    translation = _ref2.translation,\n\t\t\t    actions = _ref2.actions;\n\n\t\t\tvar verses = deep_get(this.state.books, [book, chapter, 'translations', translation, 'verses'], []);\n\t\t\tif (reference) reference = reference.split(':');\n\n\t\t\treturn (0, _jsmlI2.default)('div', { className: 'bible-book' }, (0, _jsmlI2.default)('h1', {}, book, \" \", chapter), (0, _jsmlI2.default)(Verses, { verses: verses, books: this.state.books,\n\t\t\t\tbook: book, chapter: chapter, reference: reference, actions: actions }));\n\t\t}\n\t}]);\n\n\treturn BibleChapter;\n}(_infernoComponent2.default);\n\nvar Lectionary = function (_Component4) {\n\t_inherits(Lectionary, _Component4);\n\n\tfunction Lectionary(props) {\n\t\t_classCallCheck(this, Lectionary);\n\n\t\tvar _this7 = _possibleConstructorReturn(this, (Lectionary.__proto__ || Object.getPrototypeOf(Lectionary)).call(this, props));\n\n\t\t_this7.state = { books: {} };return _this7;\n\t}\n\n\t_createClass(Lectionary, [{\n\t\tkey: 'componentWillMount',\n\t\tvalue: function componentWillMount() {\n\t\t\tthis.bible_data = this.props.bible_data;\n\t\t\tthis.load_data(this.props);\n\t\t}\n\t}, {\n\t\tkey: 'componentWillReceiveProps',\n\t\tvalue: function componentWillReceiveProps(props) {\n\t\t\tif (props.day != this.props.day || props.month != this.props.month || props.year != this.props.year) this.load_data(props);\n\t\t}\n\t}, {\n\t\tkey: 'load_data',\n\t\tvalue: function load_data(props) {\n\t\t\tvar _this8 = this;\n\n\t\t\tthis.bible_data.get_lectionary(props.year, props.month, props.day, props.translation, function (readings) {\n\t\t\t\t_this8.setState({ readings: readings });\n\t\t\t}, function (book, book_name, book_chapter) {\n\t\t\t\t_this8.setState({ books: Object.assign(_this8.state.books, _defineProperty({}, book_name, _defineProperty({}, book_chapter, book))) });\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: 'get_verses',\n\t\tvalue: function get_verses(book, chapter, verses) {\n\t\t\tvar _this9 = this;\n\n\t\t\tvar response = {};\n\n\t\t\tverses.map(function (verse) {\n\t\t\t\tresponse[verse - 1] = deep_get(_this9.state.books, [book, chapter, 'translations', _this9.props.translation, 'verses', verse - 1], '');\n\t\t\t});\n\t\t\treturn response;\n\t\t}\n\t}, {\n\t\tkey: 'open_reference',\n\t\tvalue: function open_reference(ref, verse) {\n\t\t\tif (!verse) verse = ref.verse;\n\t\t\tthis.props.actions.navigate('/lectionary/' + this.props.year + \"/\" + this.props.month + \"/\" + this.props.day + \"/\" + ref.source_code + \":\" + verse);\n\t\t}\n\t}, {\n\t\tkey: 'close_reference',\n\t\tvalue: function close_reference(ref, verse) {\n\t\t\tthis.props.actions.navigate('/lectionary/' + this.props.year + \"/\" + this.props.month + \"/\" + this.props.day);\n\t\t}\n\t}, {\n\t\tkey: 'render',\n\t\tvalue: function render(_ref3) {\n\t\t\tvar _this10 = this;\n\n\t\t\tvar day = _ref3.day,\n\t\t\t    month = _ref3.month,\n\t\t\t    year = _ref3.year,\n\t\t\t    reference = _ref3.reference,\n\t\t\t    translation = _ref3.translation,\n\t\t\t    actions = _ref3.actions;\n\n\t\t\tvar readings = this.state.readings || { title: '', readings: [] };\n\t\t\tif (reference) reference = reference.split(':');\n\t\t\tactions = Object.assign({}, actions, { open_reference: this.open_reference.bind(this),\n\t\t\t\tclose_reference: this.close_reference.bind(this),\n\t\t\t\tgo_to_next_reference: function go_to_next_reference(ref, refs) {\n\t\t\t\t\t_this10.props.actions.go_to_next_reference(ref, refs, _this10.open_reference.bind(_this10));\n\t\t\t\t},\n\t\t\t\tgo_to_previous_reference: function go_to_previous_reference(ref, refs) {\n\t\t\t\t\t_this10.props.actions.go_to_previous_reference(ref, refs, _this10.open_reference.bind(_this10));\n\t\t\t\t} });\n\n\t\t\treturn (0, _jsmlI2.default)('div', { className: 'bible-lectionary' }, readings.readings.map(function (reading) {\n\t\t\t\tvar chapters = {};\n\t\t\t\treading.verses.map(function (verse) {\n\t\t\t\t\tif (!chapters[verse.chapter]) chapters[verse.chapter] = [];\n\t\t\t\t\tchapters[verse.chapter].push(verse.verse);\n\t\t\t\t});\n\n\t\t\t\treturn (0, _jsmlI2.default)('div', {}, Object.keys(chapters).map(function (chapter) {\n\t\t\t\t\treturn (0, _jsmlI2.default)('span', {}, (0, _jsmlI2.default)('h1', {}, reading.label + \" - \" + reading.book, \" \", chapter), (0, _jsmlI2.default)(Verses, { verses: _this10.get_verses(reading.book, chapter, chapters[chapter]),\n\t\t\t\t\t\tbooks: _this10.state.books,\n\t\t\t\t\t\tbook: reading.book,\n\t\t\t\t\t\tchapter: chapter,\n\t\t\t\t\t\treference: reference,\n\t\t\t\t\t\tactions: actions }));\n\t\t\t\t}));\n\t\t\t}));\n\t\t}\n\t}]);\n\n\treturn Lectionary;\n}(_infernoComponent2.default);\n\nfunction LectionaryNavigation(_ref4) {\n\tvar actions = _ref4.actions,\n\t    date = _ref4.date,\n\t    nav_open = _ref4.nav_open;\n\n\treturn (0, _jsmlI2.default)('div', {}, (0, _jsmlI2.default)('div', { id: 'open-lectionary-navigation' }, (0, _jsmlI2.default)('i', { className: 'fa fa-calendar',\n\t\tonClick: function onClick() {\n\t\t\treturn actions.open_nav();\n\t\t},\n\t\tid: 'open-lectionary-button' })), nav_open && (0, _jsmlI2.default)('div', { id: 'lectionary-navigation' }, (0, _jsmlI2.default)('button', { className: 'btn',\n\t\tonClick: function onClick() {\n\t\t\treturn actions.open_today();\n\t\t} }, \"todays readings\"), (0, _jsmlI2.default)('br'), (0, _jsmlI2.default)('input', { className: 'form-control',\n\t\ttype: 'date',\n\t\tvalue: 1900 + date.getYear() + \"-\" + (date.getMonth() + 1 < 10 ? '0' : '') + (date.getMonth() + 1) + \"-\" + date.getDate(),\n\t\tonInput: function onInput(e) {\n\t\t\tactions.open_day(e.target.value.slice(2, 4), e.target.value.slice(5, 7), e.target.value.slice(8, 10));\n\t\t} })));\n}\n\nfunction Navigation(_ref5) {\n\tvar actions = _ref5.actions,\n\t    nav_open = _ref5.nav_open,\n\t    toc = _ref5.toc;\n\n\treturn (0, _jsmlI2.default)('div', {}, (0, _jsmlI2.default)('div', { id: 'open-navigation' }, (0, _jsmlI2.default)('i', { className: 'fa fa-book',\n\t\tonClick: function onClick() {\n\t\t\treturn actions.open_nav();\n\t\t},\n\t\tid: 'open-button' })), nav_open && (0, _jsmlI2.default)('div', { id: 'navigation' }, Object.keys(toc.bible).map(function (book) {\n\t\treturn (0, _jsmlI2.default)('div', {}, (0, _jsmlI2.default)('strong', {}, book), toc.bible[book].map(function (x, i) {\n\t\t\treturn (0, _jsmlI2.default)('div', { className: 'chapter-link',\n\t\t\t\tonClick: function onClick() {\n\t\t\t\t\treturn actions.open_chapter(book, i + 1);\n\t\t\t\t} }, i + 1);\n\t\t}));\n\t})));\n}\n\nfunction _get_references(book, chapter, verse, books) {\n\tvar references = deep_get(books, [book, chapter, 'references'], []);\n\tvar uniq = {};\n\tfor (var i in references) {\n\t\tuniq[references[i].text] = references[i];\n\t}references = Object.values(uniq);\n\treferences.map(function (r) {\n\t\treturn r.book = book;\n\t});\n\n\tif (!verse) return references;else return references.filter(function (x) {\n\t\treturn x.verse == verse;\n\t});\n}\n\nfunction sort_references(a, b) {\n\tif (a.verse > b.verse) return 1;else if (b.verse > a.verse) return -1;else {\n\t\tif (a.source_code + a.source_paragraph > b.source_code + b.source_paragraph) return 1;else return -1;\n\t}\n}\n\nfunction Verses(_ref6) {\n\tvar verses = _ref6.verses,\n\t    books = _ref6.books,\n\t    book = _ref6.book,\n\t    chapter = _ref6.chapter,\n\t    reference = _ref6.reference,\n\t    actions = _ref6.actions;\n\n\tvar all_references = _get_references(book, chapter, false, books).sort(sort_references);\n\treturn (0, _jsmlI2.default)('div', { className: 'verses' }, Object.keys(verses).map(function (v) {\n\t\treturn Number.parseInt(v);\n\t}).sort(function (a, b) {\n\t\treturn a > b ? 1 : -1;\n\t}).map(function (i) {\n\t\tvar verse = verses[i];\n\t\treturn (0, _jsmlI2.default)('div', { className: 'verse' }, (0, _jsmlI2.default)('div', { className: 'verse-number' }, i + 1), (0, _jsmlI2.default)('div', { className: 'main-part' }, verse), (0, _jsmlI2.default)('div', { className: 'annotations-part' }, all_references.filter(function (r) {\n\t\t\treturn r.verse == i + 1;\n\t\t}).map(function (ref) {\n\t\t\treturn [reference && reference[0] == ref.source_code && reference[1] == i + 1 && (0, _jsmlI2.default)(Reference, { reference: ref, actions: actions, all_references: all_references }), (0, _jsmlI2.default)('div', { className: 'annotation-link',\n\t\t\t\tonClick: function onClick() {\n\t\t\t\t\treturn actions.open_reference(ref, i + 1);\n\t\t\t\t} }, ref.author || ref.folder)];\n\t\t})));\n\t}));\n}\n\nfunction Reference(_ref7) {\n\tvar reference = _ref7.reference,\n\t    all_references = _ref7.all_references,\n\t    actions = _ref7.actions;\n\n\treturn (0, _jsmlI2.default)('div', { className: 'open-reference' }, (0, _jsmlI2.default)('div', { className: 'next-btn fa fa-chevron-right',\n\t\tonClick: function onClick() {\n\t\t\treturn actions.go_to_next_reference(reference, all_references);\n\t\t} }), (0, _jsmlI2.default)('div', { className: 'prev-btn fa fa-chevron-left',\n\t\tonClick: function onClick() {\n\t\t\treturn actions.go_to_previous_reference(reference, all_references);\n\t\t} }), (0, _jsmlI2.default)('div', { className: 'close-btn',\n\t\tonClick: function onClick() {\n\t\t\treturn actions.close_reference();\n\t\t} }, \"x\"), (0, _jsmlI2.default)('p', { className: 'reference-author-name' }, reference.author), (0, _jsmlI2.default)('p', {}, reference.text.replace(/\\[fn-.*?-nf\\]/g, '*')), (0, _jsmlI2.default)('p', { className: 'reference-title', style: { marginBottom: 0 } }, reference.title));\n}\n\n(0, _inferno.render)((0, _jsmlI2.default)(Main), document.querySelector(\"#main\"));\n\n//# sourceURL=webpack:///./web/main.js?");

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (klass, attrs) {\n    var children = [];\n    for (var i = 2; i < arguments.length; i++) {\n        if (arguments[i]) {\n            if (arguments[i] instanceof Array) children = children.concat(flatten(arguments[i]));else children.push(arguments[i]);\n        }\n    }attrs = attrs || {};\n    attrs.key2 = attrs.key;\n\n    if (attrs.style) {\n        var new_style = {};\n        for (var key in attrs.style) {\n            new_style[translate_key(key)] = attrs.style[key];\n        }\n        attrs.style = new_style;\n    }\n\n    var args = [klass, attrs].concat(children);\n\n    return _infernoCreateElement.createElement.apply(_infernoCreateElement.createElement, args);\n};\n\nvar _infernoCreateElement = __webpack_require__(14);\n\nfunction flatten(arr) {\n    var flattened = [];\n    for (var i in arr) {\n        if (arr[i] instanceof Array) flattened = flattened.concat(flatten(arr[i]));else if (arr[i]) flattened.push(arr[i]);\n    }\n\n    return flattened;\n}\n\nfunction translate_key(key) {\n    return key.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, '$1-$2').toLowerCase();\n}\n\n//# sourceURL=webpack:///./web/jsml-i.js?");

/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createElement\", function() { return createElement; });\n/* harmony import */ var inferno__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n\n\nfunction isNullOrUndef(o) {\n    return o === void 0 || o === null;\n}\nfunction isString(o) {\n    return typeof o === 'string';\n}\nfunction isUndefined(o) {\n    return o === void 0;\n}\n\nvar componentHooks = {\n    onComponentDidMount: 1,\n    onComponentDidUpdate: 1,\n    onComponentShouldUpdate: 1,\n    onComponentWillMount: 1,\n    onComponentWillUnmount: 1,\n    onComponentWillUpdate: 1\n};\nfunction createElement(type, props, _children) {\n    var arguments$1 = arguments;\n    var children;\n    var ref = null;\n    var key = null;\n    var className = null;\n    var flags = 0;\n    var newProps;\n    var childLen = arguments.length - 2;\n    if (childLen === 1) {\n        children = _children;\n    }\n    else if (childLen > 1) {\n        children = [];\n        while (childLen-- > 0) {\n            children[childLen] = arguments$1[childLen + 2];\n        }\n    }\n    if (isString(type)) {\n        flags = Object(inferno__WEBPACK_IMPORTED_MODULE_0__[\"getFlagsForElementVnode\"])(type);\n        if (!isNullOrUndef(props)) {\n            newProps = {};\n            for (var prop in props) {\n                if (prop === 'className' || prop === 'class') {\n                    className = props[prop];\n                }\n                else if (prop === 'key') {\n                    key = props.key;\n                }\n                else if (prop === 'children' && isUndefined(children)) {\n                    children = props.children; // always favour children args over props\n                }\n                else if (prop === 'ref') {\n                    ref = props.ref;\n                }\n                else {\n                    if (prop === 'contenteditable') {\n                        flags |= 4096 /* ContentEditable */;\n                    }\n                    newProps[prop] = props[prop];\n                }\n            }\n        }\n    }\n    else {\n        flags = 2 /* ComponentUnknown */;\n        if (!isUndefined(children)) {\n            if (!props) {\n                props = {};\n            }\n            props.children = children;\n        }\n        if (!isNullOrUndef(props)) {\n            newProps = {};\n            for (var prop$1 in props) {\n                if (prop$1 === 'key') {\n                    key = props.key;\n                }\n                else if (prop$1 === 'ref') {\n                    ref = props.ref;\n                }\n                else if (componentHooks[prop$1] === 1) {\n                    if (!ref) {\n                        ref = {};\n                    }\n                    ref[prop$1] = props[prop$1];\n                }\n                else {\n                    newProps[prop$1] = props[prop$1];\n                }\n            }\n        }\n        return Object(inferno__WEBPACK_IMPORTED_MODULE_0__[\"createComponentVNode\"])(flags, type, newProps, key, ref);\n    }\n    if (flags & 8192 /* Fragment */) {\n        return Object(inferno__WEBPACK_IMPORTED_MODULE_0__[\"createFragment\"])(childLen === 1 ? [children] : children, 0 /* UnknownChildren */, key);\n    }\n    return Object(inferno__WEBPACK_IMPORTED_MODULE_0__[\"createVNode\"])(flags, type, className, children, 0 /* UnknownChildren */, newProps, key, ref);\n}\n\n\n\n\n//# sourceURL=webpack:///./node_modules/inferno-create-element/dist/index.esm.js?");

/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Component\", function() { return Component; });\n/* harmony import */ var inferno__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n\n\nvar Component = inferno__WEBPACK_IMPORTED_MODULE_0__[\"Component\"];\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Component);\n\n\n\n//# sourceURL=webpack:///./node_modules/inferno-component/dist/index.esm.js?");

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

eval("var isarray = __webpack_require__(17)\n\n/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var defaultDelimiter = options && options.delimiter || '/'\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      continue\n    }\n\n    var next = str[index]\n    var prefix = res[2]\n    var name = res[3]\n    var capture = res[4]\n    var group = res[5]\n    var modifier = res[6]\n    var asterisk = res[7]\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n    }\n\n    var partial = prefix != null && next != null && next !== prefix\n    var repeat = modifier === '+' || modifier === '*'\n    var optional = modifier === '?' || modifier === '*'\n    var delimiter = res[2] || defaultDelimiter\n    var pattern = capture || group\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')\n    })\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index)\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path)\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options))\n}\n\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeURIComponentPretty (str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeAsterisk (str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')\n    }\n  }\n\n  return function (obj, opts) {\n    var path = ''\n    var data = obj || {}\n    var options = opts || {}\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n\n        continue\n      }\n\n      var value = data[token.name]\n      var segment\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix\n          }\n\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j])\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value)\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      })\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}          tokens\n * @param  {(Array|Object)=} keys\n * @param  {Object=}         options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options)\n    keys = []\n  }\n\n  options = options || {}\n\n  var strict = options.strict\n  var end = options.end !== false\n  var route = ''\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var prefix = escapeString(token.prefix)\n      var capture = '(?:' + token.pattern + ')'\n\n      keys.push(token)\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*'\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?'\n        } else {\n          capture = prefix + '(' + capture + ')?'\n        }\n      } else {\n        capture = prefix + '(' + capture + ')'\n      }\n\n      route += capture\n    }\n  }\n\n  var delimiter = escapeString(options.delimiter || '/')\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?'\n  }\n\n  if (end) {\n    route += '$'\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)'\n  }\n\n  return attachKeys(new RegExp('^' + route, flags(options)), keys)\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options)\n    keys = []\n  }\n\n  options = options || {}\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, /** @type {!Array} */ (keys))\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\n}\n\n\n//# sourceURL=webpack:///./node_modules/path-to-regexp/index.js?");

/***/ }),
/* 17 */
/***/ (function(module, exports) {

eval("module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n\n//# sourceURL=webpack:///./node_modules/isarray/index.js?");

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.default = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _axios = __webpack_require__(19);\n\nvar _axios2 = _interopRequireDefault(_axios);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar BibleData = function () {\n\tfunction BibleData() {\n\t\t_classCallCheck(this, BibleData);\n\n\t\tthis.bible = {};\n\t\tthis.sources = {};\n\t\tthis.readings = false;\n\t}\n\n\t_createClass(BibleData, [{\n\t\tkey: 'get_toc',\n\t\tvalue: function get_toc(next) {\n\t\t\t_axios2.default.get('data/toc.json').catch(do_nothing).then(function (response) {\n\t\t\t\tnext(response.data);\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: 'get_lectionary',\n\t\tvalue: function get_lectionary(year, month, day, translation, on_readings, on_bible) {\n\t\t\tvar _this = this;\n\n\t\t\tvar do_get_lectionary = function do_get_lectionary() {\n\t\t\t\tvar reading;\n\n\t\t\t\tfor (var i in _this.readings) {\n\t\t\t\t\treading = _this.readings[i];\n\t\t\t\t\tif (Number.parseInt(reading.day) == day && Number.parseInt(reading.month) == month && Number.parseInt(reading.year) == year) break;\n\t\t\t\t}\n\n\t\t\t\ton_readings(reading);\n\t\t\t\tvar chapters = {};\n\t\t\t\treading.readings.map(function (r) {\n\t\t\t\t\tvar book = r.book;\n\t\t\t\t\tr.verses.map(function (v) {\n\t\t\t\t\t\tvar key = [book, v.chapter].join('-');\n\t\t\t\t\t\tif (!chapters[key]) chapters[key] = { book: book, chapter: v.chapter };\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\tObject.values(chapters).map(function (item) {\n\t\t\t\t\t_this.get_chapter({ book: item.book, chapter: item.chapter, translation: translation }, on_bible);\n\t\t\t\t});\n\t\t\t};\n\n\t\t\tif (this.readings) do_get_lectionary();else _axios2.default.get('data/readings.json').catch(do_nothing).then(function (response) {\n\t\t\t\t_this.readings = response.data;\n\t\t\t\tdo_get_lectionary();\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: 'get_chapter',\n\t\tvalue: function get_chapter(options, next) {\n\t\t\tvar _this2 = this;\n\n\t\t\tvar book = options.book,\n\t\t\t    chapter = options.chapter,\n\t\t\t    verse = options.verse,\n\t\t\t    reference = options.reference,\n\t\t\t    translation = options.translation;\n\n\t\t\ttranslation = translation || 'douay';\n\t\t\tbook = book || 'matthew';\n\t\t\tchapter = chapter || 1;\n\t\t\tvar existing = deep_get(this.bible, [book, chapter]);\n\n\t\t\tif (existing && existing.translations[translation]) next(this.bible[book][chapter]);\n\n\t\t\t_axios2.default.get('data/bible/' + book + '/' + chapter + '/' + translation + '.json').catch(do_nothing).then(function (response) {\n\t\t\t\tdeep_set(_this2.bible, [book, chapter, 'translations', translation], response.data);\n\t\t\t\tnext(_this2.bible[book][chapter], book, chapter);\n\n\t\t\t\t_axios2.default.get('data/bible/' + book + '/' + chapter + '/references.json').catch(do_nothing).then(function (response, err) {\n\t\t\t\t\tif (!response) response = { data: [] };\n\n\t\t\t\t\tdeep_set(_this2.bible, [book, chapter, 'references'], response.data);\n\n\t\t\t\t\tnext(_this2.bible[book][chapter], book, chapter);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}]);\n\n\treturn BibleData;\n}();\n\nexports.default = BibleData;\n\n//# sourceURL=webpack:///./web/data.js?");

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(20);\n\n//# sourceURL=webpack:///./node_modules/axios/index.js?");

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(1);\nvar bind = __webpack_require__(2);\nvar Axios = __webpack_require__(21);\nvar mergeConfig = __webpack_require__(8);\nvar defaults = __webpack_require__(5);\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  return instance;\n}\n\n// Create the default instance to be exported\nvar axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Factory for creating new instances\naxios.create = function create(instanceConfig) {\n  return createInstance(mergeConfig(axios.defaults, instanceConfig));\n};\n\n// Expose Cancel & CancelToken\naxios.Cancel = __webpack_require__(9);\naxios.CancelToken = __webpack_require__(35);\naxios.isCancel = __webpack_require__(4);\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = __webpack_require__(36);\n\nmodule.exports = axios;\n\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = axios;\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/axios.js?");

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(1);\nvar buildURL = __webpack_require__(3);\nvar InterceptorManager = __webpack_require__(22);\nvar dispatchRequest = __webpack_require__(23);\nvar mergeConfig = __webpack_require__(8);\n\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */\nAxios.prototype.request = function request(config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof config === 'string') {\n    config = arguments[1] || {};\n    config.url = arguments[0];\n  } else {\n    config = config || {};\n  }\n\n  config = mergeConfig(this.defaults, config);\n\n  // Set config.method\n  if (config.method) {\n    config.method = config.method.toLowerCase();\n  } else if (this.defaults.method) {\n    config.method = this.defaults.method.toLowerCase();\n  } else {\n    config.method = 'get';\n  }\n\n  // Hook up interceptors middleware\n  var chain = [dispatchRequest, undefined];\n  var promise = Promise.resolve(config);\n\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    chain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    chain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  while (chain.length) {\n    promise = promise.then(chain.shift(), chain.shift());\n  }\n\n  return promise;\n};\n\nAxios.prototype.getUri = function getUri(config) {\n  config = mergeConfig(this.defaults, config);\n  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\\?/, '');\n};\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, data, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\n\nmodule.exports = Axios;\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/Axios.js?");

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(1);\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\nInterceptorManager.prototype.use = function use(fulfilled, rejected) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected\n  });\n  return this.handlers.length - 1;\n};\n\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/InterceptorManager.js?");

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(1);\nvar transformData = __webpack_require__(24);\nvar isCancel = __webpack_require__(4);\nvar defaults = __webpack_require__(5);\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  // Ensure headers exist\n  config.headers = config.headers || {};\n\n  // Transform request data\n  config.data = transformData(\n    config.data,\n    config.headers,\n    config.transformRequest\n  );\n\n  // Flatten headers\n  config.headers = utils.merge(\n    config.headers.common || {},\n    config.headers[config.method] || {},\n    config.headers\n  );\n\n  utils.forEach(\n    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n    function cleanHeaderConfig(method) {\n      delete config.headers[method];\n    }\n  );\n\n  var adapter = config.adapter || defaults.adapter;\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData(\n      response.data,\n      response.headers,\n      config.transformResponse\n    );\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData(\n          reason.response.data,\n          reason.response.headers,\n          config.transformResponse\n        );\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/dispatchRequest.js?");

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(1);\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\nmodule.exports = function transformData(data, headers, fns) {\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn(data, headers);\n  });\n\n  return data;\n};\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/transformData.js?");

/***/ }),
/* 25 */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(1);\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/normalizeHeaderName.js?");

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar createError = __webpack_require__(7);\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n  if (!validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(createError(\n      'Request failed with status code ' + response.status,\n      response.config,\n      null,\n      response.request,\n      response\n    ));\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/settle.js?");

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Update an Error with the specified config, error code, and response.\n *\n * @param {Error} error The error to update.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The error.\n */\nmodule.exports = function enhanceError(error, config, code, request, response) {\n  error.config = config;\n  if (code) {\n    error.code = code;\n  }\n\n  error.request = request;\n  error.response = response;\n  error.isAxiosError = true;\n\n  error.toJSON = function() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: this.config,\n      code: this.code\n    };\n  };\n  return error;\n};\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/enhanceError.js?");

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar isAbsoluteURL = __webpack_require__(30);\nvar combineURLs = __webpack_require__(31);\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n * @returns {string} The combined full path\n */\nmodule.exports = function buildFullPath(baseURL, requestedURL) {\n  if (baseURL && !isAbsoluteURL(requestedURL)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n};\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/buildFullPath.js?");

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n};\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/isAbsoluteURL.js?");

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n};\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/combineURLs.js?");

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(1);\n\n// Headers whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nvar ignoreDuplicateOf = [\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n];\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) { return parsed; }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.substr(0, i)).toLowerCase();\n    val = utils.trim(line.substr(i + 1));\n\n    if (key) {\n      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {\n        return;\n      }\n      if (key === 'set-cookie') {\n        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);\n      } else {\n        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n      }\n    }\n  });\n\n  return parsed;\n};\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/parseHeaders.js?");

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(1);\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs have full support of the APIs needed to test\n  // whether the request URL is of the same origin as current location.\n    (function standardBrowserEnv() {\n      var msie = /(msie|trident)/i.test(navigator.userAgent);\n      var urlParsingNode = document.createElement('a');\n      var originURL;\n\n      /**\n    * Parse a URL to discover it's components\n    *\n    * @param {String} url The URL to be parsed\n    * @returns {Object}\n    */\n      function resolveURL(url) {\n        var href = url;\n\n        if (msie) {\n        // IE needs attribute set twice to normalize properties\n          urlParsingNode.setAttribute('href', href);\n          href = urlParsingNode.href;\n        }\n\n        urlParsingNode.setAttribute('href', href);\n\n        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n        return {\n          href: urlParsingNode.href,\n          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n          host: urlParsingNode.host,\n          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n          hostname: urlParsingNode.hostname,\n          port: urlParsingNode.port,\n          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n            urlParsingNode.pathname :\n            '/' + urlParsingNode.pathname\n        };\n      }\n\n      originURL = resolveURL(window.location.href);\n\n      /**\n    * Determine if a URL shares the same origin as the current location\n    *\n    * @param {String} requestURL The URL to test\n    * @returns {boolean} True if URL shares the same origin, otherwise false\n    */\n      return function isURLSameOrigin(requestURL) {\n        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n        return (parsed.protocol === originURL.protocol &&\n            parsed.host === originURL.host);\n      };\n    })() :\n\n  // Non standard browser envs (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return function isURLSameOrigin() {\n        return true;\n      };\n    })()\n);\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/isURLSameOrigin.js?");

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(1);\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs support document.cookie\n    (function standardBrowserEnv() {\n      return {\n        write: function write(name, value, expires, path, domain, secure) {\n          var cookie = [];\n          cookie.push(name + '=' + encodeURIComponent(value));\n\n          if (utils.isNumber(expires)) {\n            cookie.push('expires=' + new Date(expires).toGMTString());\n          }\n\n          if (utils.isString(path)) {\n            cookie.push('path=' + path);\n          }\n\n          if (utils.isString(domain)) {\n            cookie.push('domain=' + domain);\n          }\n\n          if (secure === true) {\n            cookie.push('secure');\n          }\n\n          document.cookie = cookie.join('; ');\n        },\n\n        read: function read(name) {\n          var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n          return (match ? decodeURIComponent(match[3]) : null);\n        },\n\n        remove: function remove(name) {\n          this.write(name, '', Date.now() - 86400000);\n        }\n      };\n    })() :\n\n  // Non standard browser env (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return {\n        write: function write() {},\n        read: function read() { return null; },\n        remove: function remove() {}\n      };\n    })()\n);\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/cookies.js?");

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Cancel = __webpack_require__(9);\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/cancel/CancelToken.js?");

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/spread.js?");

/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"BrowserRouter\", function() { return /* binding */ index_esm_BrowserRouter; });\n__webpack_require__.d(__webpack_exports__, \"HashRouter\", function() { return /* binding */ index_esm_HashRouter; });\n__webpack_require__.d(__webpack_exports__, \"Link\", function() { return /* binding */ Link; });\n__webpack_require__.d(__webpack_exports__, \"MemoryRouter\", function() { return /* binding */ index_esm_MemoryRouter; });\n__webpack_require__.d(__webpack_exports__, \"NavLink\", function() { return /* binding */ NavLink; });\n__webpack_require__.d(__webpack_exports__, \"Prompt\", function() { return /* binding */ Prompt; });\n__webpack_require__.d(__webpack_exports__, \"Redirect\", function() { return /* binding */ index_esm_Redirect; });\n__webpack_require__.d(__webpack_exports__, \"Route\", function() { return /* binding */ index_esm_Route; });\n__webpack_require__.d(__webpack_exports__, \"Router\", function() { return /* binding */ Router; });\n__webpack_require__.d(__webpack_exports__, \"StaticRouter\", function() { return /* binding */ index_esm_StaticRouter; });\n__webpack_require__.d(__webpack_exports__, \"Switch\", function() { return /* binding */ index_esm_Switch; });\n__webpack_require__.d(__webpack_exports__, \"matchPath\", function() { return /* binding */ matchPath; });\n__webpack_require__.d(__webpack_exports__, \"withRouter\", function() { return /* binding */ withRouter; });\n\n// EXTERNAL MODULE: ./node_modules/inferno/index.esm.js + 1 modules\nvar index_esm = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n// CONCATENATED MODULE: ./node_modules/resolve-pathname/esm/resolve-pathname.js\nfunction isAbsolute(pathname) {\n  return pathname.charAt(0) === '/';\n}\n\n// About 1.5x faster than the two-arg version of Array#splice()\nfunction spliceOne(list, index) {\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {\n    list[i] = list[k];\n  }\n\n  list.pop();\n}\n\n// This implementation is based heavily on node's url.parse\nfunction resolvePathname(to, from) {\n  if (from === undefined) from = '';\n\n  var toParts = (to && to.split('/')) || [];\n  var fromParts = (from && from.split('/')) || [];\n\n  var isToAbs = to && isAbsolute(to);\n  var isFromAbs = from && isAbsolute(from);\n  var mustEndAbs = isToAbs || isFromAbs;\n\n  if (to && isAbsolute(to)) {\n    // to is absolute\n    fromParts = toParts;\n  } else if (toParts.length) {\n    // to is relative, drop the filename\n    fromParts.pop();\n    fromParts = fromParts.concat(toParts);\n  }\n\n  if (!fromParts.length) return '/';\n\n  var hasTrailingSlash;\n  if (fromParts.length) {\n    var last = fromParts[fromParts.length - 1];\n    hasTrailingSlash = last === '.' || last === '..' || last === '';\n  } else {\n    hasTrailingSlash = false;\n  }\n\n  var up = 0;\n  for (var i = fromParts.length; i >= 0; i--) {\n    var part = fromParts[i];\n\n    if (part === '.') {\n      spliceOne(fromParts, i);\n    } else if (part === '..') {\n      spliceOne(fromParts, i);\n      up++;\n    } else if (up) {\n      spliceOne(fromParts, i);\n      up--;\n    }\n  }\n\n  if (!mustEndAbs) for (; up--; up) fromParts.unshift('..');\n\n  if (\n    mustEndAbs &&\n    fromParts[0] !== '' &&\n    (!fromParts[0] || !isAbsolute(fromParts[0]))\n  )\n    fromParts.unshift('');\n\n  var result = fromParts.join('/');\n\n  if (hasTrailingSlash && result.substr(-1) !== '/') result += '/';\n\n  return result;\n}\n\n/* harmony default export */ var resolve_pathname = (resolvePathname);\n\n// CONCATENATED MODULE: ./node_modules/value-equal/esm/value-equal.js\nfunction value_equal_valueOf(obj) {\n  return obj.valueOf ? obj.valueOf() : Object.prototype.valueOf.call(obj);\n}\n\nfunction valueEqual(a, b) {\n  // Test for strict equality first.\n  if (a === b) return true;\n\n  // Otherwise, if either of them == null they are not equal.\n  if (a == null || b == null) return false;\n\n  if (Array.isArray(a)) {\n    return (\n      Array.isArray(b) &&\n      a.length === b.length &&\n      a.every(function(item, index) {\n        return valueEqual(item, b[index]);\n      })\n    );\n  }\n\n  if (typeof a === 'object' || typeof b === 'object') {\n    var aValue = value_equal_valueOf(a);\n    var bValue = value_equal_valueOf(b);\n\n    if (aValue !== a || bValue !== b) return valueEqual(aValue, bValue);\n\n    return Object.keys(Object.assign({}, a, b)).every(function(key) {\n      return valueEqual(a[key], b[key]);\n    });\n  }\n\n  return false;\n}\n\n/* harmony default export */ var value_equal = (valueEqual);\n\n// CONCATENATED MODULE: ./node_modules/tiny-invariant/dist/tiny-invariant.esm.js\nvar isProduction = \"production\" === 'production';\nvar prefix = 'Invariant failed';\nfunction invariant(condition, message) {\n    if (condition) {\n        return;\n    }\n    if (isProduction) {\n        throw new Error(prefix);\n    }\n    throw new Error(prefix + \": \" + (message || ''));\n}\n\n/* harmony default export */ var tiny_invariant_esm = (invariant);\n\n// CONCATENATED MODULE: ./node_modules/history/esm/history.js\n\n\n\n\n\n\nfunction addLeadingSlash(path) {\n  return path.charAt(0) === '/' ? path : '/' + path;\n}\nfunction stripLeadingSlash(path) {\n  return path.charAt(0) === '/' ? path.substr(1) : path;\n}\nfunction hasBasename(path, prefix) {\n  return path.toLowerCase().indexOf(prefix.toLowerCase()) === 0 && '/?#'.indexOf(path.charAt(prefix.length)) !== -1;\n}\nfunction stripBasename(path, prefix) {\n  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;\n}\nfunction stripTrailingSlash(path) {\n  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;\n}\nfunction parsePath(path) {\n  var pathname = path || '/';\n  var search = '';\n  var hash = '';\n  var hashIndex = pathname.indexOf('#');\n\n  if (hashIndex !== -1) {\n    hash = pathname.substr(hashIndex);\n    pathname = pathname.substr(0, hashIndex);\n  }\n\n  var searchIndex = pathname.indexOf('?');\n\n  if (searchIndex !== -1) {\n    search = pathname.substr(searchIndex);\n    pathname = pathname.substr(0, searchIndex);\n  }\n\n  return {\n    pathname: pathname,\n    search: search === '?' ? '' : search,\n    hash: hash === '#' ? '' : hash\n  };\n}\nfunction createPath(location) {\n  var pathname = location.pathname,\n      search = location.search,\n      hash = location.hash;\n  var path = pathname || '/';\n  if (search && search !== '?') path += search.charAt(0) === '?' ? search : \"?\" + search;\n  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : \"#\" + hash;\n  return path;\n}\n\nfunction createLocation(path, state, key, currentLocation) {\n  var location;\n\n  if (typeof path === 'string') {\n    // Two-arg form: push(path, state)\n    location = parsePath(path);\n    location.state = state;\n  } else {\n    // One-arg form: push(location)\n    location = _extends({}, path);\n    if (location.pathname === undefined) location.pathname = '';\n\n    if (location.search) {\n      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;\n    } else {\n      location.search = '';\n    }\n\n    if (location.hash) {\n      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;\n    } else {\n      location.hash = '';\n    }\n\n    if (state !== undefined && location.state === undefined) location.state = state;\n  }\n\n  try {\n    location.pathname = decodeURI(location.pathname);\n  } catch (e) {\n    if (e instanceof URIError) {\n      throw new URIError('Pathname \"' + location.pathname + '\" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');\n    } else {\n      throw e;\n    }\n  }\n\n  if (key) location.key = key;\n\n  if (currentLocation) {\n    // Resolve incomplete/relative pathname relative to current location.\n    if (!location.pathname) {\n      location.pathname = currentLocation.pathname;\n    } else if (location.pathname.charAt(0) !== '/') {\n      location.pathname = resolve_pathname(location.pathname, currentLocation.pathname);\n    }\n  } else {\n    // When there is no prior location and pathname is empty, set it to /\n    if (!location.pathname) {\n      location.pathname = '/';\n    }\n  }\n\n  return location;\n}\nfunction locationsAreEqual(a, b) {\n  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && value_equal(a.state, b.state);\n}\n\nfunction createTransitionManager() {\n  var prompt = null;\n\n  function setPrompt(nextPrompt) {\n     false ? undefined : void 0;\n    prompt = nextPrompt;\n    return function () {\n      if (prompt === nextPrompt) prompt = null;\n    };\n  }\n\n  function confirmTransitionTo(location, action, getUserConfirmation, callback) {\n    // TODO: If another transition starts while we're still confirming\n    // the previous one, we may end up in a weird state. Figure out the\n    // best way to handle this.\n    if (prompt != null) {\n      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;\n\n      if (typeof result === 'string') {\n        if (typeof getUserConfirmation === 'function') {\n          getUserConfirmation(result, callback);\n        } else {\n           false ? undefined : void 0;\n          callback(true);\n        }\n      } else {\n        // Return false from a transition hook to cancel the transition.\n        callback(result !== false);\n      }\n    } else {\n      callback(true);\n    }\n  }\n\n  var listeners = [];\n\n  function appendListener(fn) {\n    var isActive = true;\n\n    function listener() {\n      if (isActive) fn.apply(void 0, arguments);\n    }\n\n    listeners.push(listener);\n    return function () {\n      isActive = false;\n      listeners = listeners.filter(function (item) {\n        return item !== listener;\n      });\n    };\n  }\n\n  function notifyListeners() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    listeners.forEach(function (listener) {\n      return listener.apply(void 0, args);\n    });\n  }\n\n  return {\n    setPrompt: setPrompt,\n    confirmTransitionTo: confirmTransitionTo,\n    appendListener: appendListener,\n    notifyListeners: notifyListeners\n  };\n}\n\nvar canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\nfunction getConfirmation(message, callback) {\n  callback(window.confirm(message)); // eslint-disable-line no-alert\n}\n/**\n * Returns true if the HTML5 history API is supported. Taken from Modernizr.\n *\n * https://github.com/Modernizr/Modernizr/blob/master/LICENSE\n * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js\n * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586\n */\n\nfunction supportsHistory() {\n  var ua = window.navigator.userAgent;\n  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;\n  return window.history && 'pushState' in window.history;\n}\n/**\n * Returns true if browser fires popstate on hash change.\n * IE10 and IE11 do not.\n */\n\nfunction supportsPopStateOnHashChange() {\n  return window.navigator.userAgent.indexOf('Trident') === -1;\n}\n/**\n * Returns false if using go(n) with hash history causes a full page reload.\n */\n\nfunction supportsGoWithoutReloadUsingHash() {\n  return window.navigator.userAgent.indexOf('Firefox') === -1;\n}\n/**\n * Returns true if a given popstate event is an extraneous WebKit event.\n * Accounts for the fact that Chrome on iOS fires real popstate events\n * containing undefined state when pressing the back button.\n */\n\nfunction isExtraneousPopstateEvent(event) {\n  return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;\n}\n\nvar PopStateEvent = 'popstate';\nvar HashChangeEvent = 'hashchange';\n\nfunction getHistoryState() {\n  try {\n    return window.history.state || {};\n  } catch (e) {\n    // IE 11 sometimes throws when accessing window.history.state\n    // See https://github.com/ReactTraining/history/pull/289\n    return {};\n  }\n}\n/**\n * Creates a history object that uses the HTML5 history API including\n * pushState, replaceState, and the popstate event.\n */\n\n\nfunction createBrowserHistory(props) {\n  if (props === void 0) {\n    props = {};\n  }\n\n  !canUseDOM ?  false ? undefined : tiny_invariant_esm(false) : void 0;\n  var globalHistory = window.history;\n  var canUseHistory = supportsHistory();\n  var needsHashChangeListener = !supportsPopStateOnHashChange();\n  var _props = props,\n      _props$forceRefresh = _props.forceRefresh,\n      forceRefresh = _props$forceRefresh === void 0 ? false : _props$forceRefresh,\n      _props$getUserConfirm = _props.getUserConfirmation,\n      getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm,\n      _props$keyLength = _props.keyLength,\n      keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;\n  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';\n\n  function getDOMLocation(historyState) {\n    var _ref = historyState || {},\n        key = _ref.key,\n        state = _ref.state;\n\n    var _window$location = window.location,\n        pathname = _window$location.pathname,\n        search = _window$location.search,\n        hash = _window$location.hash;\n    var path = pathname + search + hash;\n     false ? undefined : void 0;\n    if (basename) path = stripBasename(path, basename);\n    return createLocation(path, state, key);\n  }\n\n  function createKey() {\n    return Math.random().toString(36).substr(2, keyLength);\n  }\n\n  var transitionManager = createTransitionManager();\n\n  function setState(nextState) {\n    _extends(history, nextState);\n\n    history.length = globalHistory.length;\n    transitionManager.notifyListeners(history.location, history.action);\n  }\n\n  function handlePopState(event) {\n    // Ignore extraneous popstate events in WebKit.\n    if (isExtraneousPopstateEvent(event)) return;\n    handlePop(getDOMLocation(event.state));\n  }\n\n  function handleHashChange() {\n    handlePop(getDOMLocation(getHistoryState()));\n  }\n\n  var forceNextPop = false;\n\n  function handlePop(location) {\n    if (forceNextPop) {\n      forceNextPop = false;\n      setState();\n    } else {\n      var action = 'POP';\n      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n        if (ok) {\n          setState({\n            action: action,\n            location: location\n          });\n        } else {\n          revertPop(location);\n        }\n      });\n    }\n  }\n\n  function revertPop(fromLocation) {\n    var toLocation = history.location; // TODO: We could probably make this more reliable by\n    // keeping a list of keys we've seen in sessionStorage.\n    // Instead, we just default to 0 for keys we don't know.\n\n    var toIndex = allKeys.indexOf(toLocation.key);\n    if (toIndex === -1) toIndex = 0;\n    var fromIndex = allKeys.indexOf(fromLocation.key);\n    if (fromIndex === -1) fromIndex = 0;\n    var delta = toIndex - fromIndex;\n\n    if (delta) {\n      forceNextPop = true;\n      go(delta);\n    }\n  }\n\n  var initialLocation = getDOMLocation(getHistoryState());\n  var allKeys = [initialLocation.key]; // Public interface\n\n  function createHref(location) {\n    return basename + createPath(location);\n  }\n\n  function push(path, state) {\n     false ? undefined : void 0;\n    var action = 'PUSH';\n    var location = createLocation(path, state, createKey(), history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      var href = createHref(location);\n      var key = location.key,\n          state = location.state;\n\n      if (canUseHistory) {\n        globalHistory.pushState({\n          key: key,\n          state: state\n        }, null, href);\n\n        if (forceRefresh) {\n          window.location.href = href;\n        } else {\n          var prevIndex = allKeys.indexOf(history.location.key);\n          var nextKeys = allKeys.slice(0, prevIndex + 1);\n          nextKeys.push(location.key);\n          allKeys = nextKeys;\n          setState({\n            action: action,\n            location: location\n          });\n        }\n      } else {\n         false ? undefined : void 0;\n        window.location.href = href;\n      }\n    });\n  }\n\n  function replace(path, state) {\n     false ? undefined : void 0;\n    var action = 'REPLACE';\n    var location = createLocation(path, state, createKey(), history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      var href = createHref(location);\n      var key = location.key,\n          state = location.state;\n\n      if (canUseHistory) {\n        globalHistory.replaceState({\n          key: key,\n          state: state\n        }, null, href);\n\n        if (forceRefresh) {\n          window.location.replace(href);\n        } else {\n          var prevIndex = allKeys.indexOf(history.location.key);\n          if (prevIndex !== -1) allKeys[prevIndex] = location.key;\n          setState({\n            action: action,\n            location: location\n          });\n        }\n      } else {\n         false ? undefined : void 0;\n        window.location.replace(href);\n      }\n    });\n  }\n\n  function go(n) {\n    globalHistory.go(n);\n  }\n\n  function goBack() {\n    go(-1);\n  }\n\n  function goForward() {\n    go(1);\n  }\n\n  var listenerCount = 0;\n\n  function checkDOMListeners(delta) {\n    listenerCount += delta;\n\n    if (listenerCount === 1 && delta === 1) {\n      window.addEventListener(PopStateEvent, handlePopState);\n      if (needsHashChangeListener) window.addEventListener(HashChangeEvent, handleHashChange);\n    } else if (listenerCount === 0) {\n      window.removeEventListener(PopStateEvent, handlePopState);\n      if (needsHashChangeListener) window.removeEventListener(HashChangeEvent, handleHashChange);\n    }\n  }\n\n  var isBlocked = false;\n\n  function block(prompt) {\n    if (prompt === void 0) {\n      prompt = false;\n    }\n\n    var unblock = transitionManager.setPrompt(prompt);\n\n    if (!isBlocked) {\n      checkDOMListeners(1);\n      isBlocked = true;\n    }\n\n    return function () {\n      if (isBlocked) {\n        isBlocked = false;\n        checkDOMListeners(-1);\n      }\n\n      return unblock();\n    };\n  }\n\n  function listen(listener) {\n    var unlisten = transitionManager.appendListener(listener);\n    checkDOMListeners(1);\n    return function () {\n      checkDOMListeners(-1);\n      unlisten();\n    };\n  }\n\n  var history = {\n    length: globalHistory.length,\n    action: 'POP',\n    location: initialLocation,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    block: block,\n    listen: listen\n  };\n  return history;\n}\n\nvar HashChangeEvent$1 = 'hashchange';\nvar HashPathCoders = {\n  hashbang: {\n    encodePath: function encodePath(path) {\n      return path.charAt(0) === '!' ? path : '!/' + stripLeadingSlash(path);\n    },\n    decodePath: function decodePath(path) {\n      return path.charAt(0) === '!' ? path.substr(1) : path;\n    }\n  },\n  noslash: {\n    encodePath: stripLeadingSlash,\n    decodePath: addLeadingSlash\n  },\n  slash: {\n    encodePath: addLeadingSlash,\n    decodePath: addLeadingSlash\n  }\n};\n\nfunction stripHash(url) {\n  var hashIndex = url.indexOf('#');\n  return hashIndex === -1 ? url : url.slice(0, hashIndex);\n}\n\nfunction getHashPath() {\n  // We can't use window.location.hash here because it's not\n  // consistent across browsers - Firefox will pre-decode it!\n  var href = window.location.href;\n  var hashIndex = href.indexOf('#');\n  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);\n}\n\nfunction pushHashPath(path) {\n  window.location.hash = path;\n}\n\nfunction replaceHashPath(path) {\n  window.location.replace(stripHash(window.location.href) + '#' + path);\n}\n\nfunction createHashHistory(props) {\n  if (props === void 0) {\n    props = {};\n  }\n\n  !canUseDOM ?  false ? undefined : tiny_invariant_esm(false) : void 0;\n  var globalHistory = window.history;\n  var canGoWithoutReload = supportsGoWithoutReloadUsingHash();\n  var _props = props,\n      _props$getUserConfirm = _props.getUserConfirmation,\n      getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm,\n      _props$hashType = _props.hashType,\n      hashType = _props$hashType === void 0 ? 'slash' : _props$hashType;\n  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';\n  var _HashPathCoders$hashT = HashPathCoders[hashType],\n      encodePath = _HashPathCoders$hashT.encodePath,\n      decodePath = _HashPathCoders$hashT.decodePath;\n\n  function getDOMLocation() {\n    var path = decodePath(getHashPath());\n     false ? undefined : void 0;\n    if (basename) path = stripBasename(path, basename);\n    return createLocation(path);\n  }\n\n  var transitionManager = createTransitionManager();\n\n  function setState(nextState) {\n    _extends(history, nextState);\n\n    history.length = globalHistory.length;\n    transitionManager.notifyListeners(history.location, history.action);\n  }\n\n  var forceNextPop = false;\n  var ignorePath = null;\n\n  function locationsAreEqual$$1(a, b) {\n    return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash;\n  }\n\n  function handleHashChange() {\n    var path = getHashPath();\n    var encodedPath = encodePath(path);\n\n    if (path !== encodedPath) {\n      // Ensure we always have a properly-encoded hash.\n      replaceHashPath(encodedPath);\n    } else {\n      var location = getDOMLocation();\n      var prevLocation = history.location;\n      if (!forceNextPop && locationsAreEqual$$1(prevLocation, location)) return; // A hashchange doesn't always == location change.\n\n      if (ignorePath === createPath(location)) return; // Ignore this change; we already setState in push/replace.\n\n      ignorePath = null;\n      handlePop(location);\n    }\n  }\n\n  function handlePop(location) {\n    if (forceNextPop) {\n      forceNextPop = false;\n      setState();\n    } else {\n      var action = 'POP';\n      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n        if (ok) {\n          setState({\n            action: action,\n            location: location\n          });\n        } else {\n          revertPop(location);\n        }\n      });\n    }\n  }\n\n  function revertPop(fromLocation) {\n    var toLocation = history.location; // TODO: We could probably make this more reliable by\n    // keeping a list of paths we've seen in sessionStorage.\n    // Instead, we just default to 0 for paths we don't know.\n\n    var toIndex = allPaths.lastIndexOf(createPath(toLocation));\n    if (toIndex === -1) toIndex = 0;\n    var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));\n    if (fromIndex === -1) fromIndex = 0;\n    var delta = toIndex - fromIndex;\n\n    if (delta) {\n      forceNextPop = true;\n      go(delta);\n    }\n  } // Ensure the hash is encoded properly before doing anything else.\n\n\n  var path = getHashPath();\n  var encodedPath = encodePath(path);\n  if (path !== encodedPath) replaceHashPath(encodedPath);\n  var initialLocation = getDOMLocation();\n  var allPaths = [createPath(initialLocation)]; // Public interface\n\n  function createHref(location) {\n    var baseTag = document.querySelector('base');\n    var href = '';\n\n    if (baseTag && baseTag.getAttribute('href')) {\n      href = stripHash(window.location.href);\n    }\n\n    return href + '#' + encodePath(basename + createPath(location));\n  }\n\n  function push(path, state) {\n     false ? undefined : void 0;\n    var action = 'PUSH';\n    var location = createLocation(path, undefined, undefined, history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      var path = createPath(location);\n      var encodedPath = encodePath(basename + path);\n      var hashChanged = getHashPath() !== encodedPath;\n\n      if (hashChanged) {\n        // We cannot tell if a hashchange was caused by a PUSH, so we'd\n        // rather setState here and ignore the hashchange. The caveat here\n        // is that other hash histories in the page will consider it a POP.\n        ignorePath = path;\n        pushHashPath(encodedPath);\n        var prevIndex = allPaths.lastIndexOf(createPath(history.location));\n        var nextPaths = allPaths.slice(0, prevIndex + 1);\n        nextPaths.push(path);\n        allPaths = nextPaths;\n        setState({\n          action: action,\n          location: location\n        });\n      } else {\n         false ? undefined : void 0;\n        setState();\n      }\n    });\n  }\n\n  function replace(path, state) {\n     false ? undefined : void 0;\n    var action = 'REPLACE';\n    var location = createLocation(path, undefined, undefined, history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      var path = createPath(location);\n      var encodedPath = encodePath(basename + path);\n      var hashChanged = getHashPath() !== encodedPath;\n\n      if (hashChanged) {\n        // We cannot tell if a hashchange was caused by a REPLACE, so we'd\n        // rather setState here and ignore the hashchange. The caveat here\n        // is that other hash histories in the page will consider it a POP.\n        ignorePath = path;\n        replaceHashPath(encodedPath);\n      }\n\n      var prevIndex = allPaths.indexOf(createPath(history.location));\n      if (prevIndex !== -1) allPaths[prevIndex] = path;\n      setState({\n        action: action,\n        location: location\n      });\n    });\n  }\n\n  function go(n) {\n     false ? undefined : void 0;\n    globalHistory.go(n);\n  }\n\n  function goBack() {\n    go(-1);\n  }\n\n  function goForward() {\n    go(1);\n  }\n\n  var listenerCount = 0;\n\n  function checkDOMListeners(delta) {\n    listenerCount += delta;\n\n    if (listenerCount === 1 && delta === 1) {\n      window.addEventListener(HashChangeEvent$1, handleHashChange);\n    } else if (listenerCount === 0) {\n      window.removeEventListener(HashChangeEvent$1, handleHashChange);\n    }\n  }\n\n  var isBlocked = false;\n\n  function block(prompt) {\n    if (prompt === void 0) {\n      prompt = false;\n    }\n\n    var unblock = transitionManager.setPrompt(prompt);\n\n    if (!isBlocked) {\n      checkDOMListeners(1);\n      isBlocked = true;\n    }\n\n    return function () {\n      if (isBlocked) {\n        isBlocked = false;\n        checkDOMListeners(-1);\n      }\n\n      return unblock();\n    };\n  }\n\n  function listen(listener) {\n    var unlisten = transitionManager.appendListener(listener);\n    checkDOMListeners(1);\n    return function () {\n      checkDOMListeners(-1);\n      unlisten();\n    };\n  }\n\n  var history = {\n    length: globalHistory.length,\n    action: 'POP',\n    location: initialLocation,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    block: block,\n    listen: listen\n  };\n  return history;\n}\n\nfunction clamp(n, lowerBound, upperBound) {\n  return Math.min(Math.max(n, lowerBound), upperBound);\n}\n/**\n * Creates a history object that stores locations in memory.\n */\n\n\nfunction createMemoryHistory(props) {\n  if (props === void 0) {\n    props = {};\n  }\n\n  var _props = props,\n      getUserConfirmation = _props.getUserConfirmation,\n      _props$initialEntries = _props.initialEntries,\n      initialEntries = _props$initialEntries === void 0 ? ['/'] : _props$initialEntries,\n      _props$initialIndex = _props.initialIndex,\n      initialIndex = _props$initialIndex === void 0 ? 0 : _props$initialIndex,\n      _props$keyLength = _props.keyLength,\n      keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;\n  var transitionManager = createTransitionManager();\n\n  function setState(nextState) {\n    _extends(history, nextState);\n\n    history.length = history.entries.length;\n    transitionManager.notifyListeners(history.location, history.action);\n  }\n\n  function createKey() {\n    return Math.random().toString(36).substr(2, keyLength);\n  }\n\n  var index = clamp(initialIndex, 0, initialEntries.length - 1);\n  var entries = initialEntries.map(function (entry) {\n    return typeof entry === 'string' ? createLocation(entry, undefined, createKey()) : createLocation(entry, undefined, entry.key || createKey());\n  }); // Public interface\n\n  var createHref = createPath;\n\n  function push(path, state) {\n     false ? undefined : void 0;\n    var action = 'PUSH';\n    var location = createLocation(path, state, createKey(), history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      var prevIndex = history.index;\n      var nextIndex = prevIndex + 1;\n      var nextEntries = history.entries.slice(0);\n\n      if (nextEntries.length > nextIndex) {\n        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);\n      } else {\n        nextEntries.push(location);\n      }\n\n      setState({\n        action: action,\n        location: location,\n        index: nextIndex,\n        entries: nextEntries\n      });\n    });\n  }\n\n  function replace(path, state) {\n     false ? undefined : void 0;\n    var action = 'REPLACE';\n    var location = createLocation(path, state, createKey(), history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      history.entries[history.index] = location;\n      setState({\n        action: action,\n        location: location\n      });\n    });\n  }\n\n  function go(n) {\n    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);\n    var action = 'POP';\n    var location = history.entries[nextIndex];\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (ok) {\n        setState({\n          action: action,\n          location: location,\n          index: nextIndex\n        });\n      } else {\n        // Mimic the behavior of DOM histories by\n        // causing a render after a cancelled POP.\n        setState();\n      }\n    });\n  }\n\n  function goBack() {\n    go(-1);\n  }\n\n  function goForward() {\n    go(1);\n  }\n\n  function canGo(n) {\n    var nextIndex = history.index + n;\n    return nextIndex >= 0 && nextIndex < history.entries.length;\n  }\n\n  function block(prompt) {\n    if (prompt === void 0) {\n      prompt = false;\n    }\n\n    return transitionManager.setPrompt(prompt);\n  }\n\n  function listen(listener) {\n    return transitionManager.appendListener(listener);\n  }\n\n  var history = {\n    length: entries.length,\n    action: 'POP',\n    location: entries[index],\n    index: index,\n    entries: entries,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    canGo: canGo,\n    block: block,\n    listen: listen\n  };\n  return history;\n}\n\n\n\n// EXTERNAL MODULE: ./node_modules/path-to-regexp-es6/index.js\nvar path_to_regexp_es6 = __webpack_require__(10);\nvar path_to_regexp_es6_default = /*#__PURE__*/__webpack_require__.n(path_to_regexp_es6);\n\n// EXTERNAL MODULE: ./node_modules/hoist-non-inferno-statics/index.js\nvar hoist_non_inferno_statics = __webpack_require__(11);\nvar hoist_non_inferno_statics_default = /*#__PURE__*/__webpack_require__.n(hoist_non_inferno_statics);\n\n// CONCATENATED MODULE: ./node_modules/inferno-router/dist/index.esm.js\n\n\n\n\n\nvar isArray = Array.isArray;\nfunction isInvalid(o) {\n    return o === null || o === false || o === true || o === void 0;\n}\nfunction combineFrom(first, second) {\n    var out = {};\n    if (first) {\n        for (var key in first) {\n            out[key] = first[key];\n        }\n    }\n    if (second) {\n        for (var key$1 in second) {\n            out[key$1] = second[key$1];\n        }\n    }\n    return out;\n}\n\nfunction index_esm_invariant(condition, format, a, b, c, d, e, f) {\n    if (!condition) {\n        var error;\n        if (format === undefined) {\n            error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n        }\n        else {\n            var args = [a, b, c, d, e, f];\n            var argIndex = 0;\n            error = new Error(format.replace(/%s/g, function () {\n                return args[argIndex++];\n            }));\n            error.name = 'Invariant Violation';\n        }\n        error.framesToPop = 1; // we don't care about invariant's own frame\n        throw error;\n    }\n}\n\n/**\n * The public API for putting history on context.\n */\nvar Router = /*@__PURE__*/(function (Component) {\n    function Router(props, context) {\n        Component.call(this, props, context);\n        this.state = {\n            match: this.computeMatch(props.history.location.pathname)\n        };\n    }\n\n    if ( Component ) Router.__proto__ = Component;\n    Router.prototype = Object.create( Component && Component.prototype );\n    Router.prototype.constructor = Router;\n    Router.prototype.getChildContext = function getChildContext () {\n        var childContext = combineFrom(this.context.router, null);\n        childContext.history = this.props.history;\n        childContext.route = {\n            location: childContext.history.location,\n            match: this.state.match\n        };\n        return {\n            router: childContext\n        };\n    };\n    Router.prototype.computeMatch = function computeMatch (pathname) {\n        return {\n            isExact: pathname === '/',\n            params: {},\n            path: '/',\n            url: '/'\n        };\n    };\n    Router.prototype.componentWillMount = function componentWillMount () {\n        var this$1 = this;\n\n        var ref = this.props;\n        var history = ref.history;\n        // Do this here so we can setState when a <Redirect> changes the\n        // location in componentWillMount. This happens e.g. when doing\n        // server rendering using a <StaticRouter>.\n        this.unlisten = history.listen(function () {\n            this$1.setState({\n                match: this$1.computeMatch(history.location.pathname)\n            });\n        });\n    };\n    Router.prototype.componentWillUnmount = function componentWillUnmount () {\n        this.unlisten();\n    };\n    Router.prototype.render = function render (props) {\n        return props.children;\n    };\n\n    return Router;\n}(index_esm[\"Component\"]));\n\nfunction objectWithoutProperties (obj, exclude) { var target = {}; for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k]; return target; }\nfunction index_esm_addLeadingSlash(path) {\n    return path.charAt(0) === '/' ? path : '/' + path;\n}\n// tslint:disable-next-line:no-empty\nvar noop = function () { };\nvar index_esm_StaticRouter = /*@__PURE__*/(function (Component) {\n    function StaticRouter() {\n        var this$1 = this;\n\n        Component.apply(this, arguments);\n        this.createHref = function (path) { return index_esm_addLeadingSlash(this$1.props.basename + createURL(path)); };\n        this.handlePush = function (location) {\n            var ref = this$1.props;\n            var basename = ref.basename;\n            var context = ref.context;\n            context.action = 'PUSH';\n            context.location = addBasename(basename, index_esm_createLocation(location));\n            context.url = createURL(context.location);\n        };\n        this.handleReplace = function (location) {\n            var ref = this$1.props;\n            var basename = ref.basename;\n            var context = ref.context;\n            context.action = 'REPLACE';\n            context.location = addBasename(basename, index_esm_createLocation(location));\n            context.url = createURL(context.location);\n        };\n        // tslint:disable-next-line:no-empty\n        this.handleListen = function () { return noop; };\n        // tslint:disable-next-line:no-empty\n        this.handleBlock = function () { return noop; };\n    }\n\n    if ( Component ) StaticRouter.__proto__ = Component;\n    StaticRouter.prototype = Object.create( Component && Component.prototype );\n    StaticRouter.prototype.constructor = StaticRouter;\n    StaticRouter.prototype.getChildContext = function getChildContext () {\n        return {\n            router: {\n                staticContext: this.props.context\n            }\n        };\n    };\n    StaticRouter.prototype.render = function render (ref) {\n        var basename = ref.basename;\n        var context = ref.context;\n        var location = ref.location;\n        var rest = objectWithoutProperties( ref, [\"basename\", \"context\", \"location\"] );\n        var props = rest;\n\n        return Object(index_esm[\"createComponentVNode\"])(4 /* ComponentClass */, Router, combineFrom(props, {\n            history: {\n                action: 'POP',\n                block: this.handleBlock,\n                createHref: this.createHref,\n                go: staticHandler('go'),\n                goBack: staticHandler('goBack'),\n                goForward: staticHandler('goForward'),\n                listen: this.handleListen,\n                location: index_esm_stripBasename(basename, index_esm_createLocation(location)),\n                push: this.handlePush,\n                replace: this.handleReplace\n            }\n        }));\n    };\n\n    return StaticRouter;\n}(index_esm[\"Component\"]));\nindex_esm_StaticRouter.defaultProps = {\n    basename: '',\n    location: '/'\n};\nfunction normalizeLocation(ref) {\n    var pathname = ref.pathname; if ( pathname === void 0 ) pathname = '/';\n    var search = ref.search;\n    var hash = ref.hash;\n\n    return {\n        hash: (hash || '') === '#' ? '' : hash,\n        pathname: pathname,\n        search: (search || '') === '?' ? '' : search\n    };\n}\nfunction addBasename(basename, location) {\n    if (!basename) {\n        return location;\n    }\n    return combineFrom(location, { pathname: index_esm_addLeadingSlash(basename) + location.pathname });\n}\nfunction index_esm_stripBasename(basename, location) {\n    if (!basename) {\n        return location;\n    }\n    var base = index_esm_addLeadingSlash(basename);\n    if (location.pathname.indexOf(base) !== 0) {\n        return location;\n    }\n    return combineFrom(location, { pathname: location.pathname.substr(base.length) });\n}\nfunction index_esm_createLocation(location) {\n    return typeof location === 'string' ? parsePath(location) : normalizeLocation(location);\n}\nfunction createURL(location) {\n    return typeof location === 'string' ? location : createPath(location);\n}\nfunction staticHandler(methodName) {\n    return function () {\n        index_esm_invariant(false, 'You cannot %s with <StaticRouter>', methodName);\n    };\n}\n\nvar index_esm_BrowserRouter = /*@__PURE__*/(function (Component) {\n    function BrowserRouter(props, context) {\n        Component.call(this, props, context);\n        this.history = createBrowserHistory(props);\n    }\n\n    if ( Component ) BrowserRouter.__proto__ = Component;\n    BrowserRouter.prototype = Object.create( Component && Component.prototype );\n    BrowserRouter.prototype.constructor = BrowserRouter;\n    BrowserRouter.prototype.render = function render () {\n        return Object(index_esm[\"createComponentVNode\"])(4 /* ComponentClass */, Router, {\n            children: this.props.children,\n            history: this.history\n        });\n    };\n\n    return BrowserRouter;\n}(index_esm[\"Component\"]));\n\nvar index_esm_HashRouter = /*@__PURE__*/(function (Component) {\n    function HashRouter(props, context) {\n        Component.call(this, props, context);\n        this.history = createHashHistory(props);\n    }\n\n    if ( Component ) HashRouter.__proto__ = Component;\n    HashRouter.prototype = Object.create( Component && Component.prototype );\n    HashRouter.prototype.constructor = HashRouter;\n    HashRouter.prototype.render = function render () {\n        return Object(index_esm[\"createComponentVNode\"])(4 /* ComponentClass */, Router, {\n            children: this.props.children,\n            history: this.history\n        });\n    };\n\n    return HashRouter;\n}(index_esm[\"Component\"]));\n\nvar index_esm_MemoryRouter = /*@__PURE__*/(function (Component) {\n    function MemoryRouter(props, context) {\n        Component.call(this, props, context);\n        this.history = createMemoryHistory(props);\n    }\n\n    if ( Component ) MemoryRouter.__proto__ = Component;\n    MemoryRouter.prototype = Object.create( Component && Component.prototype );\n    MemoryRouter.prototype.constructor = MemoryRouter;\n    MemoryRouter.prototype.render = function render () {\n        return Object(index_esm[\"createComponentVNode\"])(4 /* ComponentClass */, Router, {\n            children: this.props.children,\n            history: this.history\n        });\n    };\n\n    return MemoryRouter;\n}(index_esm[\"Component\"]));\n\nvar patternCache = {};\nvar cacheLimit = 10000;\nvar cacheCount = 0;\nvar compilePath = function (pattern, options) {\n    var cacheKey = \"\" + (options.end) + (options.strict) + (options.sensitive);\n    var cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});\n    if (cache[pattern]) {\n        return cache[pattern];\n    }\n    var keys = [];\n    var re = path_to_regexp_es6_default()(pattern, keys, options);\n    var compiledPattern = { re: re, keys: keys };\n    if (cacheCount < cacheLimit) {\n        cache[pattern] = compiledPattern;\n        cacheCount++;\n    }\n    return compiledPattern;\n};\n/**\n * Public API for matching a URL pathname to a path pattern.\n */\nfunction matchPath(pathname, options) {\n    if (typeof options === 'string') {\n        options = { path: options };\n    }\n    var path = options.path; if ( path === void 0 ) path = '/';\n    var exact = options.exact; if ( exact === void 0 ) exact = false;\n    var strict = options.strict; if ( strict === void 0 ) strict = false;\n    var sensitive = options.sensitive; if ( sensitive === void 0 ) sensitive = false;\n    var ref = compilePath(path, { end: exact, strict: strict, sensitive: sensitive });\n    var re = ref.re;\n    var keys = ref.keys;\n    var match = re.exec(pathname);\n    if (!match) {\n        return null;\n    }\n    var url = match[0];\n    var values = match.slice(1);\n    var isExact = pathname === url;\n    if (exact && !isExact) {\n        return null;\n    }\n    return {\n        isExact: isExact,\n        params: keys.reduce(function (memo, key, index) {\n            memo[key.name] = values[index];\n            return memo;\n        }, {}),\n        path: path,\n        url: path === '/' && url === '' ? '/' : url // the matched portion of the URL\n    };\n}\n\n/**\n * The public API for matching a single path and rendering.\n */\nvar index_esm_Route = /*@__PURE__*/(function (Component) {\n    function Route(props, context) {\n        Component.call(this, props, context);\n        this.state = {\n            match: this.computeMatch(props, context.router)\n        };\n    }\n\n    if ( Component ) Route.__proto__ = Component;\n    Route.prototype = Object.create( Component && Component.prototype );\n    Route.prototype.constructor = Route;\n    Route.prototype.getChildContext = function getChildContext () {\n        var childContext = combineFrom(this.context.router, null);\n        childContext.route = {\n            location: this.props.location || this.context.router.route.location,\n            match: this.state.match\n        };\n        return {\n            router: childContext\n        };\n    };\n\n    Route.prototype.computeMatch = function computeMatch (ref, router) {\n        var computedMatch = ref.computedMatch;\n        var location = ref.location;\n        var path = ref.path;\n        var strict = ref.strict;\n        var exact = ref.exact;\n        var sensitive = ref.sensitive;\n\n        if (computedMatch) {\n            // <Switch> already computed the match for us\n            return computedMatch;\n        }\n        var route = router.route;\n        var pathname = (location || route.location).pathname;\n        return path ? matchPath(pathname, { path: path, strict: strict, exact: exact, sensitive: sensitive }) : route.match;\n    };\n    Route.prototype.componentWillReceiveProps = function componentWillReceiveProps (nextProps, nextContext) {\n        this.setState({\n            match: this.computeMatch(nextProps, nextContext.router)\n        });\n    };\n    Route.prototype.render = function render () {\n        var ref = this.state;\n        var match = ref.match;\n        var ref$1 = this.props;\n        var children = ref$1.children;\n        var component = ref$1.component;\n        var render = ref$1.render;\n        var ref$2 = this.context.router;\n        var history = ref$2.history;\n        var route = ref$2.route;\n        var staticContext = ref$2.staticContext;\n        var location = this.props.location || route.location;\n        var props = { match: match, location: location, history: history, staticContext: staticContext };\n        if (component) {\n            return match ? Object(index_esm[\"createComponentVNode\"])(2 /* ComponentUnknown */, component, props) : null;\n        }\n        if (render) {\n            return match ? render(props, this.context) : null;\n        }\n        if (typeof children === 'function') {\n            return children(props);\n        }\n        return children;\n    };\n\n    return Route;\n}(index_esm[\"Component\"]));\n\nfunction getMatch(ref, route, location) {\n    var path = ref.path;\n    var exact = ref.exact;\n    var strict = ref.strict;\n    var sensitive = ref.sensitive;\n    var from = ref.from;\n\n    var pathProp = path || from;\n    return pathProp ? matchPath(location.pathname, { path: pathProp, exact: exact, strict: strict, sensitive: sensitive }) : route.match;\n}\nfunction extractMatchFromChildren(children, route, location) {\n    var match;\n    var _child;\n    if (isArray(children)) {\n        for (var i = 0; i < children.length; ++i) {\n            _child = children[i];\n            if (isArray(_child)) {\n                var nestedMatch = extractMatchFromChildren(_child, route, location);\n                match = nestedMatch.match;\n                _child = nestedMatch._child;\n            }\n            else {\n                match = getMatch(_child.props, route, location);\n            }\n            if (match) {\n                break;\n            }\n        }\n    }\n    else {\n        match = getMatch(children.props, route, location);\n        _child = children;\n    }\n    return { match: match, _child: _child };\n}\nvar index_esm_Switch = /*@__PURE__*/(function (Component) {\n    function Switch () {\n        Component.apply(this, arguments);\n    }\n\n    if ( Component ) Switch.__proto__ = Component;\n    Switch.prototype = Object.create( Component && Component.prototype );\n    Switch.prototype.constructor = Switch;\n\n    Switch.prototype.render = function render () {\n        var ref = this.context.router;\n        var route = ref.route;\n        var ref$1 = this.props;\n        var children = ref$1.children;\n        var location = this.props.location || route.location;\n        if (isInvalid(children)) {\n            return null;\n        }\n        var ref$2 = extractMatchFromChildren(children, route, location);\n        var match = ref$2.match;\n        var _child = ref$2._child;\n        if (match) {\n            return Object(index_esm[\"createComponentVNode\"])(_child.flags, _child.type, combineFrom(_child.props, { location: location, computedMatch: match }));\n        }\n        return null;\n    };\n\n    return Switch;\n}(index_esm[\"Component\"]));\n\nfunction objectWithoutProperties$1 (obj, exclude) { var target = {}; for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k]; return target; }\nvar isModifiedEvent = function (event) { return Boolean(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey); };\nfunction handleClick(ref, event) {\n    var props = ref.props;\n    var context = ref.context;\n\n    if (props.onClick) {\n        props.onClick(event);\n    }\n    if (!event.defaultPrevented && // onClick prevented default\n        event.button === 0 && // ignore everything but left clicks\n        !props.target && // let browser handle \"target=_blank\" etc.\n        !isModifiedEvent(event) // ignore clicks with modifier keys\n    ) {\n        event.preventDefault();\n        var ref$1 = context.router;\n        var history = ref$1.history;\n        var replace = props.replace; if ( replace === void 0 ) replace = false;\n        var to = props.to;\n        if (replace) {\n            history.replace(to);\n        }\n        else {\n            history.push(to);\n        }\n    }\n}\n/**\n * The public API for rendering a history-aware <a>.\n */\nfunction Link(props, context) {\n    var replace = props.replace;\n    var children = props.children;\n    var className = props.className;\n    var to = props.to; if ( to === void 0 ) to = '';\n    var innerRef = props.innerRef;\n    var rest$1 = objectWithoutProperties$1( props, [\"replace\", \"children\", \"className\", \"to\", \"innerRef\"] );\n    var rest = rest$1;\n    index_esm_invariant(context.router, 'You should not use <Link> outside a <Router>');\n    var href = context.router.history.createHref(typeof to === 'string' ? { pathname: to } : to);\n    var newProps = combineFrom(rest, null);\n    newProps.href = href;\n    newProps.onClick = Object(index_esm[\"linkEvent\"])({\n        context: context,\n        props: props\n    }, handleClick);\n    return Object(index_esm[\"createVNode\"])(1 /* HtmlElement */, 'a', className, children, 0 /* UnknownChildren */, newProps, null, innerRef);\n}\n\nfunction objectWithoutProperties$2 (obj, exclude) { var target = {}; for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k]; return target; }\nfunction filter(i) {\n    return i;\n}\n/**\n * A <Link> wrapper that knows if it's \"active\" or not.\n */\nfunction NavLink(ref) {\n    var to = ref.to;\n    var exact = ref.exact;\n    var strict = ref.strict;\n    var onClick = ref.onClick;\n    var linkLocation = ref.location;\n    var activeClassName = ref.activeClassName; if ( activeClassName === void 0 ) activeClassName = 'active';\n    var className = ref.className;\n    var activeStyle = ref.activeStyle;\n    var style = ref.style;\n    var getIsActive = ref.isActive;\n    var ariaCurrent = ref.ariaCurrent; if ( ariaCurrent === void 0 ) ariaCurrent = 'true';\n    var rest$1 = objectWithoutProperties$2( ref, [\"to\", \"exact\", \"strict\", \"onClick\", \"location\", \"activeClassName\", \"className\", \"activeStyle\", \"style\", \"isActive\", \"ariaCurrent\"] );\n    var rest = rest$1;\n\n    function linkComponent(ref) {\n        var location = ref.location;\n        var match = ref.match;\n\n        var isActive = !!(getIsActive ? getIsActive(match, location) : match);\n        return Object(index_esm[\"createComponentVNode\"])(8 /* ComponentFunction */, Link, combineFrom({\n            'aria-current': isActive && ariaCurrent,\n            className: isActive ? [className, activeClassName].filter(filter).join(' ') : className,\n            onClick: onClick,\n            style: isActive ? combineFrom(style, activeStyle) : style,\n            to: to\n        }, rest));\n    }\n    return Object(index_esm[\"createComponentVNode\"])(4 /* ComponentClass */, index_esm_Route, {\n        children: linkComponent,\n        exact: exact,\n        location: linkLocation,\n        path: typeof to === 'object' ? to.pathname : to,\n        strict: strict\n    });\n}\n\n/**\n * The public API for matching a single path and rendering.\n */\nvar Prompt = /*@__PURE__*/(function (Component) {\n    function Prompt () {\n        Component.apply(this, arguments);\n    }\n\n    if ( Component ) Prompt.__proto__ = Component;\n    Prompt.prototype = Object.create( Component && Component.prototype );\n    Prompt.prototype.constructor = Prompt;\n\n    Prompt.prototype.enable = function enable (message) {\n        if (this.unblock) {\n            this.unblock();\n        }\n        this.unblock = this.context.router.history.block(message);\n    };\n    Prompt.prototype.disable = function disable () {\n        if (this.unblock) {\n            this.unblock();\n            this.unblock = null;\n        }\n    };\n    Prompt.prototype.componentWillMount = function componentWillMount () {\n        index_esm_invariant(this.context.router, 'You should not use <Prompt> outside a <Router>');\n        if (this.props.when) {\n            this.enable(this.props.message);\n        }\n    };\n    Prompt.prototype.componentWillReceiveProps = function componentWillReceiveProps (nextProps) {\n        if (nextProps.when) {\n            if (!this.props.when || this.props.message !== nextProps.message) {\n                this.enable(nextProps.message);\n            }\n        }\n        else {\n            this.disable();\n        }\n    };\n    Prompt.prototype.componentWillUnmount = function componentWillUnmount () {\n        this.disable();\n    };\n    Prompt.prototype.render = function render () {\n        return null;\n    };\n\n    return Prompt;\n}(index_esm[\"Component\"]));\n\nvar index_esm_Redirect = /*@__PURE__*/(function (Component) {\n    function Redirect () {\n        Component.apply(this, arguments);\n    }\n\n    if ( Component ) Redirect.__proto__ = Component;\n    Redirect.prototype = Object.create( Component && Component.prototype );\n    Redirect.prototype.constructor = Redirect;\n\n    Redirect.prototype.isStatic = function isStatic () {\n        return this.context.router && this.context.router.staticContext;\n    };\n    Redirect.prototype.componentWillMount = function componentWillMount () {\n        index_esm_invariant(this.context.router, 'You should not use <Redirect> outside a <Router>');\n        if (this.isStatic()) {\n            this.perform();\n        }\n    };\n    Redirect.prototype.componentDidMount = function componentDidMount () {\n        if (!this.isStatic()) {\n            this.perform();\n        }\n    };\n    Redirect.prototype.componentDidUpdate = function componentDidUpdate (prevProps) {\n        var prevTo = createLocation(prevProps.to);\n        var nextTo = createLocation(this.props.to);\n        if (locationsAreEqual(prevTo, nextTo)) {\n            // tslint:disable-next-line:no-console\n            console.error((\"You tried to redirect to the same route you're currently on: \\\"\" + (nextTo.pathname) + (nextTo.search) + \"\\\"\"));\n            return;\n        }\n        this.perform();\n    };\n    Redirect.prototype.perform = function perform () {\n        var ref = this.context.router;\n        var history = ref.history;\n        var ref$1 = this.props;\n        var push = ref$1.push; if ( push === void 0 ) push = false;\n        var to = ref$1.to;\n        if (push) {\n            history.push(to);\n        }\n        else {\n            history.replace(to);\n        }\n    };\n    Redirect.prototype.render = function render () {\n        return null;\n    };\n\n    return Redirect;\n}(index_esm[\"Component\"]));\n\nfunction objectWithoutProperties$3 (obj, exclude) { var target = {}; for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k]; return target; }\n/**\n * A public higher-order component to access the imperative API\n */\nfunction withRouter(Com) {\n    var C = function (props) {\n        var wrappedComponentRef = props.wrappedComponentRef;\n        var rest = objectWithoutProperties$3( props, [\"wrappedComponentRef\"] );\n        var remainingProps = rest;\n        return Object(index_esm[\"createComponentVNode\"])(4 /* ComponentClass */, index_esm_Route, {\n            render: function render(routeComponentProps) {\n                return Object(index_esm[\"createComponentVNode\"])(2 /* ComponentUnknown */, Com, combineFrom(remainingProps, routeComponentProps), null, wrappedComponentRef);\n            }\n        });\n    };\n    C.displayName = \"withRouter(\" + (Com.displayName || Com.name) + \")\";\n    C.WrappedComponent = Com;\n    return hoist_non_inferno_statics_default()(C, Com);\n}\n\n\n\n\n//# sourceURL=webpack:///./node_modules/inferno-router/dist/index.esm.js_+_5_modules?");

/***/ })
/******/ ]);